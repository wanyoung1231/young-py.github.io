<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小乌龟 の blog</title>
    <description>关于Python及生活随记</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Flask教程 —— 模板（下）</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;4、链接&lt;/h3&gt;

&lt;p&gt;任何应用程序都有多个路由总是需要包含链接来连接到不同的页面，例如导航栏。&lt;/p&gt;

&lt;p&gt;在模板中，对于简单的路由直接写URLs做链接是非常的琐碎麻烦的，但是对于带有变量部分的动态路由建立正确的URLs会变得更加复杂。此外，在代码中显示的写URLs会在路由上创建不必要的依赖。如果路由重组，模板中的链接将被打断而变得无法访问。&lt;/p&gt;

&lt;p&gt;为了避免这些问题，Flask提供&lt;code&gt;url_for()&lt;/code&gt;帮助函数，它将从存放在应用程序的URL映射中生成URLs。&lt;/p&gt;

&lt;p&gt;其最简单的方法，这个函数传入视图函数名（或通过&lt;code&gt;app.add_url_route()&lt;/code&gt;定义的路由&lt;code&gt;endpoint&lt;/code&gt;名）作为它的参数，然后返回它的URL。例如，在当前版本的&lt;code&gt;hello.py&lt;/code&gt;调用&lt;code&gt;url_for(&#39;index&#39;)&lt;/code&gt;将返回&lt;code&gt;/&lt;/code&gt;。调用&lt;code&gt;url_for(&#39;index&#39;, _external=True)&lt;/code&gt;将返回一个绝对URL，在该示例中为&lt;code&gt;http://localhost:5000/&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：相对URLs可以满足生成链接来连接应用程序不同的路由。绝对URLs只有在链接被用于web浏览器的外部才是必须的，例如通过邮件发送链接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;动态URLs可以使用&lt;code&gt;url_for()&lt;/code&gt;来生成通过传递动态部分作为关键字参数。例如，&lt;code&gt;url_for(&#39;user&#39;, name=&#39;join&#39;, external=True)&lt;/code&gt;会返回http://localhost:5000/user/john。&lt;/p&gt;

&lt;p&gt;发送给&lt;code&gt;url_for()&lt;/code&gt;的关键字参数不限制被用于动态路由。函数会增加任何扩展参数给放回字符串。例如&lt;code&gt;url_for(&#39;index&#39;, page=2)&lt;/code&gt;会返回&lt;code&gt;/?page=2&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5、静态文件&lt;/h3&gt;

&lt;p&gt;Web应用程序不仅仅是由Python代码和模板组成。大部分的应用程序会使用静态文件，例如从HTML代码中引用的图片、JavaScript源文件和CSS。&lt;/p&gt;

&lt;p&gt;你可能需要回忆一下，在第二章中检查&lt;code&gt;hello.py&lt;/code&gt;应用程序的URL映射时，一个&lt;strong&gt;static&lt;/strong&gt;入口出现在里面。这也是为什么引用定义成&lt;code&gt;/static/&amp;lt;filename&amp;gt;&lt;/code&gt;的静态文件会被当作特殊路由来对待。例如，一个&lt;code&gt;url_for(&#39;static&#39;, filename=&#39;css/style.css&#39;, _external=True)&lt;/code&gt;调用会返回http://localhost:5000/static/css/styles.css。&lt;/p&gt;

&lt;p&gt;在它的默认配置中，Flask在位于应用程序的根目录下名为&lt;code&gt;static&lt;/code&gt;的子目录中寻找静态文件。可以在这个目录下的子目录组织管理文件。当服务器收到来自上一个示例的URL，它会产生一个响应包含位于&lt;code&gt;static/css/styles.css&lt;/code&gt;的文件内容。&lt;/p&gt;

&lt;p&gt;示例3-10展示应用程序可以包含一个位于&lt;code&gt;static/css/styles.css&lt;/code&gt;的&lt;code&gt;favicon.icon&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-10. templates/base.html：favicon定义&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % block head %}
{ { super() }}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;shortcut icon&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;{ { url_for(&amp;#39;static&amp;#39;, filename = &amp;#39;favicon.ico&amp;#39;) }}&amp;quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;image/x-icon&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;{ { url_for(&amp;#39;static&amp;#39;, filename = &amp;#39;favicon.ico&amp;#39;) }}&amp;quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;image/x-icon&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; { % endblock %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;图标定义被插入在&lt;code&gt;head&lt;/code&gt;块里的最下面。注意&lt;code&gt;super()&lt;/code&gt;是如何保留定义在基础模板中的块的原始内容的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 3d&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;flask-moment&quot;&gt;6、Flask-Moment中的本地化日期和时间&lt;/h3&gt;

&lt;p&gt;当用户工作在世界各个不同的地方，在web应用程序中处理日期和时间就变成了一个比较重要的问题。&lt;/p&gt;

&lt;p&gt;协程篇进行修改，包括对子例程的调整、升级版调整，添加应用场景&lt;/p&gt;

</description>
        <pubDate>Mon, 03 Nov 2014 21:21:35 +0800</pubDate>
        <link>/flask/2014/11/03/flask-3-3.html</link>
        <guid isPermaLink="true">/flask/2014/11/03/flask-3-3.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 模板（中）</title>
        <description>&lt;h3 id=&quot;twitter-bootstrapflask-bootstrap&quot;&gt;2、集成Twitter Bootstrap的Flask-Bootstrap&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Bootstrap&lt;/strong&gt;是Twitter的一个开源框架，提供用户交互组件来创建一个清新且有吸引力的web页面，并兼容所有现代web浏览器。&lt;/p&gt;

&lt;p&gt;Bootstrap是一个客户端框架，服务端不直接参与。服务端需要做的就是提供HTML响应，引用层叠样式表（CSS）和JavaScript文件并通过HTML、CSS、和JavaScript代码来实例化需要的组件。模板是做这些的理想地方。&lt;/p&gt;

&lt;p&gt;集成Bootstrap到应用程序最好的方式是在模板中做一些必要的改变。一个简单点的途径就是使用Flask-Bootstrap扩展去简化集成工作。可以通过pip来安装Flask-Bootstrap：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ pip install flask-bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flask扩展通常在应用程序实例被创建的时候初始化。示例3-4展示Flask-Bootstrap的初始化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-4. hello.py：Flask-Bootstrap初始化&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask.ext.bootstrap&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bootstrap&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# ...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bootstrap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bootstrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;和第二章的Flask-Script一样，Flask-Bootstrap从&lt;code&gt;flask.ext&lt;/code&gt;命名空间导入并通过传递应用程序实例到构造函数来初始化。&lt;/p&gt;

&lt;p&gt;一旦Flask-Bootstrap被初始化，一个包含所有Bootstrap文件的基础模板就可供应用程序使用了。这个模板利用Jinja2的&lt;strong&gt;模板继承&lt;/strong&gt;，应用程序则可以扩展一个拥有通用页面结构，且包含Bootstrap导入的元素的基础模板。示例3-5展示作为派生模板的新版&lt;code&gt;user.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;_示例3-5. templates/user.html： 使用Flask-Bootstrap的模板&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &amp;quot;bootstrap/base.html&amp;quot; %}
{ % block title %}Flasky{ % endblock %}
{ % block navbar %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar navbar-inverse&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navigation&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-header&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;button&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-toggle&amp;quot;&lt;/span&gt; 
        &lt;span class=&quot;na&quot;&gt;data-toggle=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;collapse&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-target=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;.navbar-collapse&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;sr-only&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Toggle navigation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon-bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon-bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon-bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-brand&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Flasky&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-collapse collapse&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;nav navbar-nav&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Home&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt; 
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{ % endblock %}

{ % block content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;page-header&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello, !&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{ % endblock %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Jinja2的&lt;strong&gt;extends&lt;/strong&gt;指令通过从Flask-Bootstrap引用&lt;code&gt;bootstrap/base.html&lt;/code&gt;来实现模板的继承。Flask-Bootstrap的基础模板提供一个包含Bootstrap CSS和JavaScript文件的web页面骨架。&lt;/p&gt;

&lt;p&gt;基础模板定义了一些可以被派生模板重写的&lt;strong&gt;block&lt;/strong&gt;。&lt;code&gt;block&lt;/code&gt;和&lt;code&gt;endblock&lt;/code&gt;指令定义了被添加到基础模板中block的内容。&lt;/p&gt;

&lt;p&gt;上面的&lt;code&gt;user.html&lt;/code&gt;模板定义了三个block，分别命名为&lt;code&gt;title&lt;/code&gt;、&lt;code&gt;navbar&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;。基础模板里的这些block输出派生模板定义的内容。&lt;code&gt;title&lt;/code&gt;块比较简单；它的内容将出现在&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签内，然后被渲染在HTML文档的头部 。&lt;code&gt;navbar&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;块则是为页面保留的导航栏和主内容。&lt;/p&gt;

&lt;p&gt;在这个模板中，&lt;code&gt;navbar&lt;/code&gt;块使用Bootstrap组件定义了一个简单的导航栏。&lt;code&gt;content&lt;/code&gt;块有个名为&lt;code&gt;container&lt;/code&gt;的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;，里面嵌套了名为&lt;code&gt;page-header&lt;/code&gt;的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;。图3-1展示这些操作后应用程序长成啥样了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 3b&lt;/code&gt;来切换到这个版本的应用程序。&lt;a href=&quot;http://www.bootcss.com/&quot;&gt;Bootstrap官方文档&lt;/a&gt; 是一个非常强大的学习资料，完全可以复制粘贴使用那些示例。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask3-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图片3-1. Twitter Bootstrap模板&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Flask-Bootstrap的&lt;code&gt;base.html&lt;/code&gt;模板定义了一些其他可供派生模板使用的&lt;code&gt;block&lt;/code&gt;。表格3-2展示了完整的可用&lt;code&gt;block&lt;/code&gt;列表。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表格3-2. Flask-Bootstrap基础模板中的block&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:285px; height:344px;&quot; src=&quot;http://young-py.github.io/imgs/flask3-03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表格3-2中的许多块用于Flask-Bootstrap自身，所以直接重写它们会引发问题。例如，&lt;code&gt;styles&lt;/code&gt;和&lt;code&gt;scripts&lt;/code&gt;块是Bootstrap定义文件的地方。如果应用程序需要新增自己的内容到已经有一些内容的块中，则必须使用Jinja2的&lt;code&gt;super()&lt;/code&gt;。例如，如何在派生模板中写&lt;code&gt;scripts&lt;/code&gt;块，来给文档增加新的JavaScript文件：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % block scripts %}
{ { super() }}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;my-script.js&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt; 
{ % endblock %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;3、自定义错误页面&lt;/h3&gt;

&lt;p&gt;当你输入错误路径在你的浏览器地址栏，你会得到404错误代码页面。目前的错误页面很普通也没有吸引力，且没有一致的使用Bootstrap页面。&lt;/p&gt;

&lt;p&gt;Flask允许应用程序自定义基于模板的错误页面，就像常规的路由。两个最常见的错误代码，404是在客户端请求的页面或路径不存在的时候触发；500是当存在未处理的异常时触发。示例3-6展示如何为这两个错误提供自定义处理。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-6. hello.py：自定义错误页面&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@app.errorhandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;404&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;page_not_found&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;404.html&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;404&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.errorhandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;internal_server_error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;500.html&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;错误处理返回响应，和视图函数一样。同时返回相应错误的数字状态码。&lt;/p&gt;

&lt;p&gt;在错误处理中引用的模板需要自己去写。这些模板需要和常规的页面一样的布局，所以在这个示例中需要导航栏和页面头部显示错误信息。&lt;/p&gt;

&lt;p&gt;编写这些模板的简单方式是复制&lt;code&gt;templates/user.html&lt;/code&gt;到&lt;code&gt;templates/404.html&lt;/code&gt;和&lt;code&gt;templates/500.html&lt;/code&gt;，然后改变这两个新文件的页面头部元素来给出相应的错误信息，但这会产生很多副本。&lt;/p&gt;

&lt;p&gt;Jinja2的模板继承可以帮助我们解决这个问题。Flask-Bootstrap提供了一个带有基本布局页面的基础模板，应用程序可以定义自己的、带有完整页面布局的基础模板，包括导航栏和定义在派生模板中的页面内容。示例3-7展示了&lt;code&gt;templates/base.html&lt;/code&gt;，它是一个继承自&lt;code&gt;bootstrap/base.html&lt;/code&gt;的新模板且定义了导航栏，但对于其他模板则是一个基础模板，例如&lt;code&gt;templates/user.html&lt;/code&gt;、&lt;code&gt;templates/404.html&lt;/code&gt;和&lt;code&gt;templates/500.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;_示例3-7. templates/base.html：带有导航栏的基础应用程序模板&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &amp;quot;bootstrap/base.html&amp;quot; %}
{ % block title %}Flasky{ % endblock %}
{ % block navbar %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar navbar-inverse&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;role=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navigation&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-header&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;button&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-toggle&amp;quot;&lt;/span&gt; 
        &lt;span class=&quot;na&quot;&gt;data-toggle=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;collapse&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-target=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;.navbar-collapse&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;sr-only&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Toggle navigation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon-bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon-bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;icon-bar&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-brand&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Flasky&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;navbar-collapse collapse&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;nav navbar-nav&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Home&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt; 
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{ % endblock %}

{ % block content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  { % block page_content %}{ % endblock %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{ % endblock %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个模板中的&lt;code&gt;content&lt;/code&gt;块中只是一个名为&lt;code&gt;container&lt;/code&gt;的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，它包含了在派生模板中定义的名为&lt;code&gt;page_content&lt;/code&gt;的空block。&lt;/p&gt;

&lt;p&gt;应用程序的模板将从该模板继承而不是直接从Flask-Bootstrap继承。示例3-8展示了从&lt;code&gt;templates/base.html&lt;/code&gt;继承来构造一个自定义404错误页面是如此的简单。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-8. &lt;code&gt;templates/404.html&lt;/code&gt;：使用模板继承自定义404错误页面&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &amp;quot;base.html&amp;quot; %}
{ % block title %}Flasky - Page Not Found{ % endblock %}
{ % block page_content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;page-header&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Not Found&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{ % endblock %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;图片3-2展示在浏览器中错误页面是怎样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask3-04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图片3-2. 自定义404错误页面&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;现在&lt;code&gt;templates/user.html&lt;/code&gt;模板可以通过继承基础模板来简化它，就像示例3-9展示的这样。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-9. templates/user.html：使用模板继承简化页面模板&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &amp;quot;base.html&amp;quot; %}
{ % block title %}Flasky{ % endblock %}
{ % block page_content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;page-header&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello, !&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{ % endblock %}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 3c&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 31 Oct 2014 17:27:05 +0800</pubDate>
        <link>/flask/2014/10/31/flask-3-2.html</link>
        <guid isPermaLink="true">/flask/2014/10/31/flask-3-2.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 模板（上）</title>
        <description>&lt;p&gt;写代码最关键的是要易于维护且结构清晰整洁。目前为止，你看到的例子都过于简单从而没有做这方面的要求。Flask视图函数希望将两个应该完全独立的任务一并处理，两个任务有两种代码，一并处理势必会引发问题。&lt;/p&gt;

&lt;p&gt;明摆着的任务就是&lt;strong&gt;生成响应&lt;/strong&gt;，就像你在第二章看到的示例那样。对于最简单的请求确实已经足够，但是一般而言一个请求会触发应用程序的状态发生改变，而视图函数就是产生这个改变的地方。&lt;/p&gt;

&lt;p&gt;例如，用户在网站上注册一个新的账户。用户输入邮箱地址和密码到表单并点击提交按钮。一个包含数据的请求从用户到服务器，Flask将其派发给视图函数去处理这个注册请求。这个视图函数需要告诉数据库添加新的用户并生成一个响应发回给浏览器。这两类任务通常被称作&lt;strong&gt;业务逻辑&lt;/strong&gt;和&lt;strong&gt;显示逻辑&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;混合业务逻辑和显示逻辑会导致代码非常的难以理解和维护。想象一下，将从数据库获取的数据和必要的HTML字符串文字进行连接，生成一堆的HTML代码是多么蛋疼的一件事情。而如果将显示逻辑移到模板中去，则势必极大提高应用程序的可维护性。&lt;/p&gt;

&lt;p&gt;模板就是包含响应文本的文件，带有占位符变量的动态部分只在请求上下文中被知道。用真实的值替换变量并返回最终响应字符串，这个过程称为&lt;strong&gt;渲染&lt;/strong&gt;。对于渲染模板任务，Flask使用强大的模板引擎&lt;strong&gt;Jinja2&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;jinja2&quot;&gt;1、Jinja2模板引擎&lt;/h3&gt;

&lt;p&gt;Jinja2模板最简单的形式就是一个包含响应文本的文件。示例3-1展示了Jinja2模板匹配示例2-1中&lt;code&gt;index()&lt;/code&gt;视图函数响应。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-1. templates/index.html：Jinja2模板&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例2-2中视图函数&lt;code&gt;user()&lt;/code&gt;返回的响应有一个动态部分，该部分由一个变量代表。示例3-2展示模板实现该响应。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-2. templates/user.html：Jinja2模板&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Hello, !&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section&quot;&gt;1.1、渲染模板&lt;/h5&gt;

&lt;p&gt;Flask默认会在应用程序的&lt;strong&gt;templates&lt;/strong&gt;子目录中寻找模板。下个版本的&lt;code&gt;hello.py&lt;/code&gt;，你需要将之前定义的&lt;code&gt;index.html&lt;/code&gt;和&lt;code&gt;user.html&lt;/code&gt;模板存放到新的templates文件夹下。&lt;/p&gt;

&lt;p&gt;应用程序中的视图函数需要修改来渲染这些模板。示例3-3中会展示这些变化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例3-3. hello.py：渲染模板&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# ...&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/index&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;index.html&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/user/&amp;lt;name&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;user.html&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;render_template&lt;/strong&gt;函数由集成Jinja2模板引擎的Flask提供。这个函数将模板的文件名作为它的第一个参数。任何附加的参数都是一个键/值对，分别对应被模板引用的变量和真实值。在这个示例中，第二个模板收到name变量。&lt;/p&gt;

&lt;p&gt;类似于&lt;code&gt;name=name&lt;/code&gt;的关键字参数在前面的示例中是非常常见的，但如果你不使用就很容易混淆且非常难理解。左边的“name”代表参数名称，一般在模板中用于占位符。右边的“name”在当前范围内是一个变量，为同名的参数提供真实的值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 3a&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-1&quot;&gt;1.2、变量&lt;/h5&gt;

&lt;p&gt;示例3-2的模板中的``结构引用一个变量，特殊的占位符告诉模板引擎，那个地方的值应该从模板被渲染时提供的数据中获取。&lt;/p&gt;

&lt;p&gt;Jinja2识别任何类型的变量，包括复杂的列表、字典和对象。下面是一些模板中使用变量的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;A value from a dictionary: .&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;A value from a list: .&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;A value from a list, with a variable index: .&amp;lt;/p&amp;gt; 
&amp;lt;p&amp;gt;A value from an object&#39;s method: .&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量可以通过&lt;strong&gt;filters&lt;/strong&gt;来修改，以&lt;code&gt;|&lt;/code&gt;为分隔符添加在变量名后。例如，下面的模板展示变量大写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表格3-1列出一些常用的Jinja2过滤器。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表格3-1. Jinja2变量过滤器&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask3-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;safe是比较有趣的一个过滤器。出于安全考虑，默认情况下，Jinja2会&lt;strong&gt;转义&lt;/strong&gt;所有变量。例如，如果设置变量的值为&lt;code&gt;&#39;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;&#39;&lt;/code&gt;，Jinja2将渲染字符串为&lt;code&gt;&#39;&amp;amp;lt;h1&amp;amp;gt;Hello&amp;amp;lt;/h1&amp;amp;gt;&#39;&lt;/code&gt;，这将使得h1元素显示出来且不能被浏览器解释。很多时候有必要显示存储在变量中的HTML代码，对于这些情况就可以使用safe过滤器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;警告：永远不要在不信任的值中使用safe过滤器，例如用户在web表单中输入的文本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;完整的过滤器列表可以从Jinja2官方文档中获取。&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;1.3、控制结构&lt;/h5&gt;

&lt;p&gt;Jinja2提供一些控制结构用于改变模板流。这一节用简单例子来介绍一些最有用的。&lt;/p&gt;

&lt;p&gt;下面的示例展示条件语句是怎样在模板中使用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ % if user %}
    Hello, !
{ % else %}
    Hello, Stranger!
{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;渲染一列元素在模板中是经常用到的。这个示例展示如何使用&lt;code&gt;for&lt;/code&gt;循环做到这些：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
    { % for comment in comments %} 
        &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
    { % endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jinja2同样支持&lt;strong&gt;宏&lt;/strong&gt;，这和Python代码中的函数很像。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ % macro render_comment(comment) %} 
    &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
{ % endmacro %}

&amp;lt;ul&amp;gt;
    
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了提高宏的复用性，可以将它们保存为单独的文件，然后在所有需要的地方&lt;strong&gt;导入&lt;/strong&gt;即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ % import &#39;macros.html&#39; as macros %}

&amp;lt;ul&amp;gt;
    { % for comment in comments %}
        
    { % endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要在一些地方重复使用的模板代码可以保存为一个单独的文件，所有模板都可以&lt;strong&gt;include&lt;/strong&gt;它来避免重复：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ % include &#39;common.html&#39; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个强大的复用方式是通过模板继承，这类似于Python代码中类的继承。首先创建一个名为&lt;code&gt;base.html&lt;/code&gt;的基础模板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    { % block head %}
    &amp;lt;title&amp;gt;{ % block title %}{ % endblock %} - My Application&amp;lt;/title&amp;gt; 
    { % endblock %}
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    { % block body %}
    { % endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;block&lt;/code&gt;标签定义的派生模板是可变的。在这个示例中，有&lt;code&gt;head&lt;/code&gt;、&lt;code&gt;title&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt;块；注意&lt;code&gt;title&lt;/code&gt;包含在&lt;code&gt;head&lt;/code&gt;中。下面的示例是一个基础模块的派生模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ % extends &quot;base.html&quot; %}
{ % block title %}Index{ % endblock %}
{ % block head %}
    { { super() }}
    &amp;lt;style&amp;gt;
    &amp;lt;/style&amp;gt;
{ % endblock %}
{ % block body %} 
&amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;extends&lt;/strong&gt;指令定义这个模板由&lt;code&gt;base.html&lt;/code&gt;派生。紧随这个指令之后的是三个在基础模板中定义的块，它们将在合适的位置插入。注意在基础模板中新定义的&lt;code&gt;head&lt;/code&gt;块是不为空的，所以使用&lt;code&gt;super()&lt;/code&gt; 保留原来的内容。&lt;/p&gt;

&lt;p&gt;本节呈现的所有控制结构的实际运用将在后面展示，你会有机会看到它们是怎样工作的。&lt;/p&gt;

</description>
        <pubDate>Fri, 24 Oct 2014 04:19:30 +0800</pubDate>
        <link>/flask/2014/10/24/flask-3-1.html</link>
        <guid isPermaLink="true">/flask/2014/10/24/flask-3-1.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 基本应用程序结构（下）</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;5、请求-响应循环&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;现在你已经玩过一个基本的Flask应用程序，你也许想要知道更多关于Flask如何施展魔力。下面章节描述了一些框架设计方面的特点。&lt;/p&gt;

&lt;h5 id=&quot;contextcontext&quot;&gt;&lt;strong&gt;5.1、应用程序Context和请求Context&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;当Flask从客户端收到一个请求，它需要提供几个可用对象给视图函数处理。&lt;strong&gt;request对象&lt;/strong&gt;是个不错的例子，它封装了客户端发送的HTTP请求。&lt;/p&gt;

&lt;p&gt;Flask视图函数访问request对象的最好方式，就是作为一个参数发送它，但这需要每个单一视图函数在应用程序中有一个额外的参数。考虑一下，如果request对象不是唯一一个视图函数需要访问完成请求的对象，事情将会变得更加复杂。&lt;/p&gt;

&lt;p&gt;为了避免弄乱视图函数那些可能需要或不需要的参数，Flask使用&lt;strong&gt;context&lt;/strong&gt;来临时确定可访问的全局对象。也多亏了context，视图函数可以写成下面这样：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user_agent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;User-Agent&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;p&amp;gt;Your browser is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_agent&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意，在这个视图函数中，request是如何被作为一个全局变量来使用的。现实中，request是不能作为全局变量的，如果是多线程服务器，同一时间线程作用于不同客户端的不同请求，所以每一个线程需要看到request中的不同对象。contexts使得Flask确定可访问的全局变量而不干扰其他线程。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：线程是可以独立管理的最小指令序列。一个进程中有多个活动的线程是非常常见的，有时分享内存或文件句柄资源。多线程web服务器会启动一个线程池并从池中选择一个线程来处理每个传入的请求。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Flask有两类context： &lt;em&gt;应用级context&lt;/em&gt; 和 &lt;em&gt;请求级context&lt;/em&gt; 。表2-1展示了这些context提供的变量。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;表2-1. Flask全局context&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask2-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Flask激活（或压栈）应用级context和请求级context在调度请求之前，然后删除他们当请求被处理后。当应用程序context被压入栈，线程中&lt;code&gt;current_app&lt;/code&gt;和&lt;code&gt;g&lt;/code&gt;变量变得可用；同样的，当请求级context被压入栈，&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;session&lt;/code&gt;变量也同样变得可用。如果这些变量中的任何一个不是由激活的应用级或请求级context访问，会产生错误。在后面的章节会详细讨论四个context变量，所以不要担心你不理解它们的用处。&lt;/p&gt;

&lt;p&gt;下面的Python shell会话演示了应用级context是如何工作的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from hello import app
&amp;gt;&amp;gt;&amp;gt; from flask import current_app
&amp;gt;&amp;gt;&amp;gt; current_app.name
Traceback (most recent call last):
...
RuntimeError: working outside of the application context
&amp;gt;&amp;gt;&amp;gt; app_ctx = app.app_context()
&amp;gt;&amp;gt;&amp;gt; app_ctx.push()
&amp;gt;&amp;gt;&amp;gt; current_app.name
&#39;hello&#39;
&amp;gt;&amp;gt;&amp;gt; app_ctx.pop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个示例中，当应用级context没有激活，但是却作为有效的context被压入栈中，&lt;code&gt;current_app.name&lt;/code&gt;报错。注意在应用程序实例中一个应用级context是如何通过调用&lt;code&gt;app.app_context()&lt;/code&gt;来获得的。&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;&lt;strong&gt;5.2、请求调度&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;当一个应用程序收到客户端的请求，它需要找到响应的视图函数为之服务。对于这个任务，Flask会在应用程序的&lt;strong&gt;URL映射&lt;/strong&gt;中查找请求的URL，该映射包含URLs和操作它们的视图函数。Flask通过&lt;code&gt;app.route&lt;/code&gt;装饰器或非装饰器版本&lt;code&gt;app.add_url_rule()&lt;/code&gt;来建立这个映射。&lt;/p&gt;

&lt;p&gt;看一下Flask应用程序中URL映射是怎样的，你可以在Python shell中检查&lt;code&gt;hello.py&lt;/code&gt;创建的映射。测试中，请确保你的虚拟环境是激活状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) % python
&amp;gt;&amp;gt;&amp;gt; from hello import app
&amp;gt;&amp;gt;&amp;gt; app.url_map
Map([&amp;lt;Rule &#39;/&#39; (HEAD, OPTIONS, GET) -&amp;gt; index&amp;gt;,
  &amp;lt;Rule &#39;/static/&amp;lt;filename&amp;gt;&#39; (HEAD, OPTIONS, GET) -&amp;gt; static&amp;gt;,
  &amp;lt;Rule &#39;/user/&amp;lt;name&amp;gt;&#39; (HEAD, OPTIONS, GET) -&amp;gt; user&amp;gt;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/&lt;/code&gt;和&lt;code&gt;/user/&amp;lt;name&amp;gt;&lt;/code&gt;路由是由应用程序中的&lt;code&gt;app.route&lt;/code&gt;所定义。&lt;code&gt;/static/&amp;lt;filename&amp;gt;&lt;/code&gt;路由是由Flask添加，用于访问静态文件的一个特殊路由。你将在第三章学习更多关于静态文件的内容。&lt;/p&gt;

&lt;p&gt;URL映射中所示的&lt;code&gt;HEAD&lt;/code&gt;、&lt;code&gt;OPTIONS&lt;/code&gt;、&lt;code&gt;GET&lt;/code&gt;元素为&lt;strong&gt;request方法&lt;/strong&gt;，由路由处理。Flask连接方法到每个路由，这样不同的请求方法发送到相同的URL可以被不同的视图函数处理。&lt;code&gt;HEAD&lt;/code&gt;和&lt;code&gt;OPTIONS&lt;/code&gt;方法由Flask自动管理，所以实际上可以说，在这个应用程序中URL映射的三个路由都连接到&lt;code&gt;GET&lt;/code&gt;方法了。在第四章你将学习为路由指定不同的请求方法。&lt;/p&gt;

&lt;h5 id=&quot;hooks&quot;&gt;&lt;strong&gt;5.3、请求Hooks&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;有些时候在每个请求处理之前或之后执行代码是非常有用的。例如，在开始每一个请求前可能有必要创建数据库连接，或对用户请求进行验证。为了避免复制处理这些操作的代码到每一个视图函数中，Flask给你选择注册相同函数来调用，在请求被分配给视图函数之前或之后。&lt;/p&gt;

&lt;p&gt;请求hooks由装饰器实现。下面是四个Flask支持的hooks：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;before_first_request&lt;/code&gt;：在第一个请求被处理前注册一个函数运行。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;before_request&lt;/code&gt;：在每一个请求前注册一个函数运行。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;after_request&lt;/code&gt;：如果没有未处理的异常发生，在每一个请求后注册一个函数运行。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;teardown_request&lt;/code&gt;：即使未处理的异常发生，在每一个请求后注册一个函数运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在请求hook函数和视图函数之间共享数据的惯用方法就是使用&lt;code&gt;g&lt;/code&gt;全局context。例如，&lt;code&gt;before_request&lt;/code&gt;处理程序可以从数据库加载已登录的用户并保存在&lt;code&gt;g.user&lt;/code&gt;中。之后，当视图函数被调用，可以从那访问用户。&lt;/p&gt;

&lt;p&gt;请求hooks的示例会在未来的章节中展示给大家，所以不用担心，&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;&lt;strong&gt;5.4、响应&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;当Flask调用一个视图函数，并期望它的返回值去响应该请求。大多数的响应是将简单字符串构成的HTML页面发回给客户端。&lt;/p&gt;

&lt;p&gt;但是HTTP协议需要比字符串更多的信息作为请求的响应。一个HTTP响应中非常重要的部分是&lt;strong&gt;状态码&lt;/strong&gt;，Flask默认设置200来指示请求已经成功处理。&lt;/p&gt;

&lt;p&gt;当视图函数需要用不同的状态码响应，可以在响应文本后添加数字码作为第二个返回值。例如，下面的视图函数返回400错误状态码的请求：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Bad Request&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;400&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;视图函数返回的响应还可以携带第三个参数，添加一个头部字典给HTTP响应。通常很少用到，但是你可以在第十四章看到示例。&lt;/p&gt;

&lt;p&gt;除了返回一个、两个或三个值的元组，Flask视图函数可以选择返回&lt;strong&gt;response对象&lt;/strong&gt;。&lt;code&gt;make_response()&lt;/code&gt;函数可携带一个、两个或三个参数，和视图函数返回的值一样，并返回一个response对象。有时候在视图函数中执行这个转换是非常有用的，然后使用response对象中的方法进一步配置响应。下面的示例创建response对象并设置cookie：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_response&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;This document carries a cookie!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_cookie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;answer&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;42&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有一类特殊的响应称作&lt;strong&gt;重定向&lt;/strong&gt;。这类响应不包含页面文档；只是给浏览器一个新的URL去加载新的页面。重定向通常和web表单一起使用，你将在第四章学习。&lt;/p&gt;

&lt;p&gt;重定向通常由302响应状态码注明并且重定向的URL由头部的&lt;code&gt;Location&lt;/code&gt;给出。重定向响应可以使用三个值的返回生成，也可通过响应对象生成，但是鉴于它频繁的使用，Flask提供&lt;code&gt;redirect()&lt;/code&gt;函数来创建这样的响应：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redirect&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redirect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;http://www.example.com&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另一个具有中断功能的特殊响应用来错误处理。下面的示例，当URL给出的id动态参数不是一个合法的用户时返回状态码404：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/user/&amp;lt;id&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;abort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;404&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意终止不是指将控制权返回给调用它的函数，而是指通过抛出异常将控制权返回给web服务。&lt;/p&gt;

&lt;h3 id=&quot;flask&quot;&gt;&lt;strong&gt;6、Flask扩展&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Flask是可扩展的。它故意腾出地给重要的功能，例如数据库和用户授权，给你自由去选择最适合你的应用程序的包，或写一个自己想要的。&lt;/p&gt;

&lt;p&gt;社区开发了非常多的&lt;strong&gt;扩展&lt;/strong&gt;用于各种用途，如果这还不够，可以使用任何Python标准包和库。为了让你了解一个扩展是如何并入一个应用程序的，下面的章节给hello.py添加一个扩展，增加应用程序的命令行参数。&lt;/p&gt;

&lt;h5 id=&quot;flask-script&quot;&gt;&lt;strong&gt;6.1、Flask-Script命令行选项&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;Flask开发，其web服务器支持一系列的启动配置选项，但是配置它们的唯一方式只有在脚本中传递参数给&lt;code&gt;app.run()&lt;/code&gt;并调用。这不是非常的方便，理想方法是通过命令行参数传递配置选项。&lt;/p&gt;

&lt;p&gt;Flask-Script是给你的Flask应用程序添加命令行解释的扩展。它打包了一组通用的选项，还支持自定义命令。&lt;/p&gt;

&lt;p&gt;使用pip安装扩展：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ pip install flask-script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例2-3展示了在 &lt;em&gt;hello.py&lt;/em&gt; 应用程序中添加命令行解释的变化。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例2-3. hello.py：使用Flask-Script&lt;/em&gt; &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask.ext.script&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Manager&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Manager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# ...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;专为Flask开发的扩展暴露在&lt;code&gt;flask.ext&lt;/code&gt;命名空间下。Flask-Script从&lt;code&gt;flask.ext.script&lt;/code&gt;中导出一个名为&lt;code&gt;Manager&lt;/code&gt;的类。&lt;/p&gt;

&lt;p&gt;初始化这个扩展的方法和其他许多扩展一样：主类实例的初始化是通过将应用程序实例作为参数传递给构造函数实现的。创建的对象适当的用于每一个扩展。在这个示例中，服务器启动通过&lt;code&gt;manager.run()&lt;/code&gt;来路由，且命令行在这被解析。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 2c&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为这些变化，应用程序获得一组基本的命令行选项。运行&lt;code&gt;hello.py&lt;/code&gt;显示可用信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python hello.py
usage: hello.py [-h] {shell, runserver} ...

positional arguments:
  {shell, runserver}
    shell           在Flask应用程序上下文的内部运行一个Python Shell。
    runserver       运行Flask开发服务器，例如：app.run()

optional arguments:
  -h, --help        显示这个帮助信息并退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;命令用于在应用程序上下文中启动一个Python shell会话。你可以使用这个会话去运行维护任务，或测试，或调试错误。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runserver&lt;/code&gt;命令，就像它的名称一样，启动web服务。运行&lt;code&gt;python hello.py runserver&lt;/code&gt;在调试模式下启动web服务，还有更多的选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ python hello.py runserver --help
usage: hello.py runserver [-h] [-t HOST] [-p PORT] [--threaded]
                          [--processes PROCESSES] [--passthrough-errors] [-d]
                          [-r]

运行Flask开发服务器，例如：app.run()

optional arguments:
  -h, --help             显示这个帮助信息并退出
  -t HOST, --host HOST
  -p PORT, --port PORT
  --threaded
  --processes PROCESSES
  --passthrough-errors
  -d, --no-debug
  -r, --no-reload 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--host&lt;/code&gt;参数是一个非常有用的选项，因为它能告诉web服务器监听哪个网络接口的客户端连接。默认，Flask开发的web服务器监听&lt;code&gt;localhost&lt;/code&gt;的连接，所以只有来自内部计算机运行的服务器可以接收。下面的命令使得web服务器监听公网接口，其他网络上的计算机可以连接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv) $ python hello.py runserver --host 0.0.0.0
 * Running on http://0.0.0.0:5000/
 * Restarting with reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在web服务器应该可以从网络中的任何一台计算机访问 &lt;em&gt;http://a.b.c.d:5000&lt;/em&gt; ，“a.b.c.d”是运行服务的计算机的外部IP地址。&lt;/p&gt;

&lt;p&gt;这一章介绍了请求响应的概念，但说的更多的是响应。Flask使用&lt;strong&gt;模板&lt;/strong&gt;为生成响应提供非常好的支持，这是非常重要的话题，下一章会重点讲它。&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Oct 2014 01:31:30 +0800</pubDate>
        <link>/flask/2014/10/20/flask-2-2.html</link>
        <guid isPermaLink="true">/flask/2014/10/20/flask-2-2.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet源码剖析2</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt4.jpg&quot; alt=&quot;&quot; /&gt;
敬请期待。。。&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Oct 2014 04:10:25 +0800</pubDate>
        <link>/gevent/2014/10/16/gevent3.html</link>
        <guid isPermaLink="true">/gevent/2014/10/16/gevent3.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 基本应用程序结构（上）</title>
        <description>&lt;p&gt;在这一章，你将学习Flask应用程序不同部分。同时你将编写和运行你的第一个Flask web应用程序。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;1、初始化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在这章，你将学到Flask应用程序的不同部分。同时，你将编写和运行你的第一个Flask web应用程序。&lt;/p&gt;

&lt;p&gt;所有的Flask应用程序都必须创建一个 &lt;em&gt;应用程序实例&lt;/em&gt; 。使用web服务器网关接口协议将所有从客户端接收的请求传递给这个对象处理。这个应用程序实例就是&lt;strong&gt;Flask&lt;/strong&gt;类的一个对象，通常使用下面的方式创建：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的&lt;code&gt;__name__&lt;/code&gt;变量就是那个正确的、你需要传递的值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：对于Flask开发者来说，传给Flask应用程序构造函数的&lt;code&gt;name&lt;/code&gt;参数是比较容易弄混淆的。Flask使用这个参数来确定应用程序的根目录，这样以后可以相对这个路径来找到资源文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;稍后你可以看到更复杂的应用程序实例初始化，但是对于简单应用程序这些已经足够了。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;2、路由和视图函数&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;客户端例如web浏览器发送 &lt;em&gt;请求&lt;/em&gt; 给web服务，进而将它们发送给Flask应用程序实例。应用程序实例需要知道对于各个URL请求需要运行哪些代码，所以它给Python函数建立了一个URLs映射。这些在URL和函数之间建立联系的操作被称之为 &lt;em&gt;路由&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;在Flask应程序中定义路由的最便捷的方式是通过显示定义在应用程序实例之上的&lt;code&gt;app.route&lt;/code&gt;装饰器，注册被装饰的函数来作为一个路由。下面的例子会演示怎样使用装饰器来申明一个路由：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：装饰器是Python语言的标准特性；它们可以以不同方式改变函数的行为。一个常见的模式是使用装饰器来注册函数作为一个事件处理程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在上一个示例给应用程序的根URL注册&lt;code&gt;index()&lt;/code&gt;函数作为事件的处理程序。如果这个应用程序被部署在服务器上并绑定了 &lt;em&gt;www.example.com&lt;/em&gt; 域名，然后在你的浏览器地址栏中输入 &lt;em&gt;http://www.example.com&lt;/em&gt; 将触发&lt;code&gt;index()&lt;/code&gt;来运行服务。客户端接收到的这个函数的返回值被称为 &lt;em&gt;响应&lt;/em&gt; 。如果客户端是web浏览器，响应则是显示给用户的文档。&lt;/p&gt;

&lt;p&gt;类似于&lt;code&gt;index()&lt;/code&gt;的函数被称作 &lt;em&gt;视图函数&lt;/em&gt; 。通过视图返回的响应可以是简单的HTML内容的字符串，但它也可以市更复杂的形式，正如您将看到的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：响应字符串嵌入在Python代码中导致代码难以掌控，在此只是介绍响应的概念。你将在第三章学习正确的方法来生成响应。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你注意到你每天使用的一些网站URLs如何形成的，你将会发现很多都有变量。例如，你的Facebook个人信息页的URL是 &lt;em&gt;http://www.facebook.com/&amp;lt;username&amp;gt;&lt;/em&gt; ，所以你的用户名是它的一部分。Flask在路由装饰器中使用特殊的语法支持这些类型的URLs。下面的示例定义了一个拥有动态名称组件的路由：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/user/&amp;lt;name&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用尖括号括起来的部分是动态的部分，所以任何URLs匹配到静态部分都将映射到这个路由。当视图函数被调用，Flask发送动态组件作为一个参数。在前面的示例的视图函数中，这个参数是用于生成一个个性的问候作为响应。&lt;/p&gt;

&lt;p&gt;在路由中动态组件默认为字符串，但是可以定义为其他类型。例如，路由&lt;code&gt;/user/&amp;lt;int:id&amp;gt;&lt;/code&gt;只匹配有一个整数在id动态段的URLs。Flask路由支持int、float和path。path同样是字符串类型，但并不认为斜杠是分隔符，而认为它们是动态组件的一部分。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;3、服务启动&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;应用程序实例有一个&lt;code&gt;run&lt;/code&gt;方法用于启动Flask集成的web服务：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;__name__ == &#39;__main__&#39;&lt;/code&gt;在此处使用是用于确保web服务已经启动当脚本被立即执行。当脚本被另一个脚本导入，它被看做父脚本将启动不同的服务，所以&lt;code&gt;app.run()&lt;/code&gt;调用会被跳过。&lt;/p&gt;

&lt;p&gt;一旦服务启动，它将进入循环等待请求并为之服务。这个循环持续到应用程序停止，例如通过按下&lt;code&gt;Ctrl-C&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有几个选项参数可以给&lt;code&gt;app.run()&lt;/code&gt;配置web服务的操作模式。在开发期间，可以很方便的开启debug模式，将激活 &lt;em&gt;debugger&lt;/em&gt; 和 &lt;em&gt;reloader&lt;/em&gt; 。这样做是通过传递debug为True来实现的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Flask提供的web服务并不用于生产环境。你将在十七章学习生产环境的web服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;&lt;strong&gt;4、一个完整的应用程序&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在上一节，你学习了Flask web应用程序的不同部分，现在是时候写一个了。整个 &lt;em&gt;hello.py&lt;/em&gt; 应用程序脚本只不过将前面描述的三个部分结合在一个文件中。应用程序示例2-1所示。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例2-1 hello.py：一个完整的Flask应用程序&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 2a&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运行应用程序之前，请确保你在之前创建的虚拟环境已经是激活状态且已安装Flask。现在打开你的web浏览器并在地址栏输入 &lt;em&gt;http://127.0.0.1:5000/&lt;/em&gt; 。图像2-1显示连接到应用程序后的web浏览器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask2-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图像2-1 hello.py Flask应用程序&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;然后输入以下命令启动应用程序：
    (venv) $ python hello.py
     * Running on http://127.0.0.1:5000/
     * Restarting with reloader&lt;/p&gt;

&lt;p&gt;如果你输入任何其他URL，应用程序将不知道如何操作它并且将返回错误代码404给浏览器——当你访问一个不存在的网页也会得到该错误。&lt;/p&gt;

&lt;p&gt;示例2-2所示应用程序的增强版添加了第二个动态路由。当你访问这个URI，你应该可以看到一个个性的问候。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例2-2 hello.py：带有动态路由的Flask应用程序&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/user/&amp;lt;name&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序，你现在可以运行&lt;code&gt;git checkout 2b&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;测试动态路由，确保服务正在运行随后访问 &lt;em&gt;http://localhost:5000/user/Dave&lt;/em&gt; 。生成的应用程序会使用动态参数名响应一个定制的问候。尝试不同的名称，看看视图函数总是生成响应基于给定的名称。图像2-2展示的一个示例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask2-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图像2-2 hello.py 动态路由&lt;/em&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Aug 2014 01:26:38 +0800</pubDate>
        <link>/flask/2014/08/19/flask-2-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/19/flask-2-1.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 安装</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;1、安装虚拟环境&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;安装&lt;strong&gt;Flask&lt;/strong&gt;最方便的方法就是使用虚拟环境。虚拟环境是在Python解释器上的一个私有复制，你可以在一个隔绝的环境下安装packages，不会影响到你系统中全局的Python解释器。&lt;/p&gt;

&lt;p&gt;虚拟环境非常有用，因为它可以防止系统出现包管理混乱和版本冲突的问题。为每个应用程序创建一个虚拟环境可以确保应用程序只能访问它们自己使用的包，从而全局解释器只作为一个源且依然整洁干净，更多的虚拟环境可以被创建。另一个好处是，虚拟环境不需要管理员权限。&lt;/p&gt;

&lt;p&gt;虚拟环境由第三方程序&lt;strong&gt;virtualenv&lt;/strong&gt;创建。检查在你的系统中是否已经安装，可以输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你得到一个错误，你需要安装该程序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Python 3.3增加了本地支持的虚拟环境通过venv模块和pyvenv命令。pyenv可以用来代替virtualenv，但是注意通过pyvenv创建的虚拟环境不包含pip，需要手动安装。这个限制会在Python 3.4中移除，到时候pyvenv可以当作完整的virtualenv替代品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大多数Linux发行版都提供一个virtualenv包。例如，Ubuntu用户就可以使用以下命令进行安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Mac OSX，你可以使用easy_install安装virtualenv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Microsoft Windows或者是任何没有提供官方virtualenv包的操作系统，接下来你会有一个稍微复杂的安装过程。&lt;/p&gt;

&lt;p&gt;使用你的web浏览器，导航到&lt;a href=&quot;https://bitbucket.org/pypa/setuptools&quot;&gt;https://bitbucket.org/pypa/setuptools&lt;/a&gt;，setuptools安装程序的主页，找到链接下载一个叫ez_setup.py安装程序脚本。保存这个文件到你电脑的临时文件夹中，然后在那个目录下运行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python ez_setup.py
$ easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：前一个命令必须由管理员权限的账户发出。在Microsoft Windows，以管理员身份选项运行命令提示符窗口。在基于Unix的系统中，两个安装命令前面必须加上&lt;code&gt;sudo&lt;/code&gt;或作为&lt;code&gt;root&lt;/code&gt;用户执行。一旦安装完毕，virtualenv程序可以通过普通账户执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你需要创建文件夹用来组织从GitHub仓库中获取的示例代码。在十三页中《如何使用示例代码》讨论的那样，最方便的方法就是使用Git客户端直接从Github中检出代码。下面的命令从GitHub中下载示例代码并初始化应用程序文件目录为“1a”版本，初始版本的应用程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/miguelgrinberg/flasky.git
$ cd flasky
$ git checkout 1a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步就是使用virtualenv命令创建Python虚拟环境到flasky文件夹中。这个命令有一个需要的参数：虚拟环境的名称。一个指定名称的文件夹和在里面的、与虚拟环境相关的所有文件会在当前目录下被创建。一般给虚拟环境约定命名为venv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv venv
New python executable in venv/bin/python2.7
Also creating executable in venv/bin/python
Installing setuptools............done.
Installing pip...............done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你有一个venv文件夹在flasky文件夹里面和一个全新的虚拟环境，包含一个私有的Python解释器。使用虚拟环境的时候，你必须“激活”它。如果你是使用bash命令行工具(Linux和Mac OSX用户)，你可以使用这个命令激活虚拟环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是使用Microsoft Windows，激活命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ venv\Scripts\activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当虚拟环境被激活了，Python解释器的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中，但是这个改动并不是永久的；它只影响当前命令会话。提醒一下，你激活了虚拟环境，该激活命令会将环境的名称包含在命令提示符里面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在虚拟环境中完成工作并想回到全局Python解释器，在命令提示符中输入&lt;code&gt;deactivate&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h3 id=&quot;pippython&quot;&gt;&lt;strong&gt;2、使用pip安装python包&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;大多数的Python包是通过&lt;strong&gt;pip&lt;/strong&gt;程序安装的，在创建虚拟环境的时候virtualenv会自动添加进去。当一个虚拟环境被激活后，pip程序的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：如果你使用pyvenv创建虚拟环境在Python 3.3中，则必须手动安装pip。安装指令在pip网站上可以找到。在Python 3.4下，pyvenv会自动安装pip。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装Flask到虚拟环境中，使用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ pip install flask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个命令，Flask和它的依赖集都会安装到虚拟环境中。你可以验证Flask是否正确安装通过启动Python解释器并试着导入它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ python
&amp;gt;&amp;gt;&amp;gt; import flask
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要安装的包比较多的时候，这样做会比较繁琐，我们还有一键安装的方法。首先新建一个文本文件，如：&lt;code&gt;requirements.txt&lt;/code&gt;，然后将你需要安装的包名保存到该文件中(根据自己的需要)，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Babel==1.3
Flask==0.10.1
Flask-Login==0.2.7
Flask-SQLAlchemy==1.0
Flask-WTF==0.9.3
Jinja2==2.7.1
SQLAlchemy==0.8.2
WTForms==1.0.5
Werkzeug==0.9.4
psycopg2==2.5.1
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你只需要输入以下命令，所有需要的包就可以全部安装好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有出现错误，祝贺你：你可以准备进入下一章节，接着你就可以写你的第一个web应用程序了。&lt;/p&gt;

</description>
        <pubDate>Sat, 16 Aug 2014 19:32:38 +0800</pubDate>
        <link>/flask/2014/08/16/flask-1-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/16/flask-1-1.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet源码剖析1</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a style=&quot;border-bottom: 2px solid #ecf0f1;&quot; href=&quot;http://blog.segmentfault.com/young_ipython/1190000000626309&quot;&gt;greenlet篇&lt;/a&gt;中只是简单讲述了一下greenlet原理，不知道有没有人对源码感兴趣的，不过我还是比较感兴趣的。对于技术我一直都觉得『
知其然，知其所以然』才是最好的，不希望自己只停留在知道用，而不知道为什么这样用。&lt;/p&gt;

&lt;p&gt;一篇可能介绍不完，所以可能需要分几部分来介绍。当我写到这的时候突然发现自己是不是写跑题了，本来是写greenlet源码分析的，结果变成了怎么去写Python扩展了。不过不管怎样，就当多学习了一些其他知识，况且分析源码肯定少不了对这些知识的了解。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;模块初始化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;greenlet是用C编写的一个扩展模块，即用Python去调用C程序。像下面这段代码，内部都是怎样的一个过程呢？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gr2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gr1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gr1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gr2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gr1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码中，我们看到&lt;code&gt;from greenlet import greenlet&lt;/code&gt;这句，相信都能明白是导入了一个模块。为什么要导入这个模块呢？这个问题有点瞧不起大家了，因为我们可能需要使用这个模块的某个功能。那在导入这个模块的时候，Python解释器需要做哪些工作呢？在使用一个类的时候，我们肯定是需要调用构造函数来初始化的，导入模块就类似于这样的一个初始化过程。所以肯定会有一个初始化函数，它长啥样？&lt;/p&gt;

&lt;p&gt;在文档中有这样一句：The initialization function must be named &lt;code&gt;initname()&lt;/code&gt;, where &lt;em&gt;name&lt;/em&gt; is the name of the module, and should be the only non-static item defined in the module file.&lt;/p&gt;

&lt;p&gt;所以对于greenlet，我们就能找到&lt;code&gt;initgreenlet(void)&lt;/code&gt;函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define INITERROR return&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 第一次导入greenlet模块时调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyMODINIT_FUNC&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initgreenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_api_object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_PyGreenlet_API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyGreenlet_API_pointers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;GREENLET_NOINLINE_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py_InitModule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;greenlet&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GreenMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;INITERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先根据模块名查找相应的初始化函数，然后&lt;code&gt;Py_InitModule()&lt;/code&gt;函数向Python解释器注册该模块中所有可以用到的方法。而&lt;code&gt;Py_InitModule()&lt;/code&gt;函数是由Python提供的C API，对于使用C API只需要包含一个头文件就可以了。&lt;/p&gt;

&lt;p&gt;官方文档描述：All function, type and macro definitions needed to use the Python/C API are included in your code by the following line:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;quot;Python.h&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;方法列表&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;看下关键代码&lt;code&gt;m = Py_InitModule(&quot;greenlet&quot;, GreenMethods)&lt;/code&gt;。官方文档描述：Create a new module object based on a name and table of functions, returning the new module object.&lt;/p&gt;

&lt;p&gt;里面提到了table of functions，在这个模块中指的就是&lt;code&gt;GreenMethods&lt;/code&gt;，一般称它为方法列表。该列表给出了所有可以被Python解释器使用的方法，将这些方法注册到这个模块中，这样在我们导入模块后就可以直接使用了。&lt;/p&gt;

&lt;p&gt;当Python程序第一次导入greenlet模块的时候，调用&lt;code&gt;initgreenlet()&lt;/code&gt;函数。接着&lt;code&gt;Py_InitModule()&lt;/code&gt;会创建一个“模块对象”（它将被插入到&lt;code&gt;sys.modules&lt;/code&gt;字典下的“greenlet”键下），并且将方法列表（PyMethodDef结构数组）构成的内建函数对象作为它的第二个参数传到刚被创建的模块中。&lt;code&gt;Py_InitModule()&lt;/code&gt;返回一个指向它创建的模块对象的指针。方法列表代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyMethodDef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GreenMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;getcurrent&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyCFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod_getcurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;METH_NOARGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*XXX*/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法列表中的各项参数如下：
&lt;img src=&quot;http://young-py.github.io/imgs/gevent3-01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(PyCFunction)mod_getcurrent&lt;/code&gt;函数如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mod_getcurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATE_OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Py_INCREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ts_current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ts_current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该函数的作用就是获取当前greenlet对象，并添加引用计数。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;一个模块的初始化工作大致是这样的。不过针对greenlet发现了一些问题，在该模块的方法列表中看到了&lt;code&gt;getcurrent&lt;/code&gt;，而其他像&lt;code&gt;switch&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;等却没有看到。随后去查阅greenlet的官方文档，看到了&lt;code&gt;greenlet.getcurrent()&lt;/code&gt;和&lt;code&gt;g.switch(*args, **kwargs)&lt;/code&gt;，却被分别安排在『实例化』和『greenlets的方法和属性』两个不同的标题之下，为什么要这样区分呢？&lt;/p&gt;

&lt;p&gt;以上部分都是一个Python C扩展模块基本的初始化工作，针对greenlet还有其他要做的。具体怎么做以及上面问题的答案就放到下一篇讲吧，因为内容比较多在这篇讲不完。&lt;/p&gt;

</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent2.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent2.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gevent文档：that uses greenlet to provide a high-level synchronous API.&lt;/p&gt;

&lt;p&gt;意思是：使用&lt;strong&gt;greenlet&lt;/strong&gt;来提供&lt;strong&gt;高级同步API&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那greenlet又是怎样一种机制呢？这个后面会稍微简单的讲一下原理，不过在后续的几篇会着重分析它的源码。在开始之前先看看提到的几个关键字『高级』、『同步』，高级不高级暂时还不知道，毕竟在实际生产环境中才看得到效果。而同步这个概念，不知道大家理解深不深刻，总之我当初理解不是很深刻，所以遇到了就聊聊呗！&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;不明白为什么会叫同步，总是让我有一种错觉，让我联想到的第一个词汇就是同时进行。不知道大家是不是和我一样，至少我看到同步是不会去想到它的正确意思。我曾一度怀疑是不是翻译错了，但是在质疑别人错之前，应该先质疑一下自己。所以我开始怀疑我的语文没学好，然后我去查了一下汉语词典，结果就悲剧了，我已经开始怀疑我的人生了。 %&amp;gt;_&amp;lt;%&lt;/p&gt;

&lt;p&gt;同步：指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;《光明日报》1984.6.2：“城市改革的步子要加快，要从解决国家与企业、企业与职工的关系入手，把适合于当前情况的各项改革措施初步配起套来，同步进行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从上面引用的话应该可以看出，国家与企业、企业与职工，都是两个相对的关系，有着各自的利益。但是他们必须合作才能完成一个共同目标，例如买票看电影。这个场景有两个动作需要完成，一个出票、一个买票，只有出票才能买票，并且这个买票的人还只能傻等，不能做其他事。&lt;/p&gt;

&lt;p&gt;同步真心不是同时进行，所以还是要多读书啊！尤其是语文！&lt;/p&gt;

&lt;p&gt;为什么这里会讲到同步呢？其实不讲也是可以的，和理解greenlet原理没有多大关系，但是和理解gevent的特性有那么点关系，因为听别人说gevent能够让你用这种同步的代码写出异步的感觉，同步的代码好理解也好处理。我没有验证过，所以我也不知道，真正的原因是感觉这个概念很容易混淆，所以就来讲讲了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;greenlet&quot;&gt;&lt;strong&gt;Greenlet&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;还记得在&lt;a style=&quot;border-bottom: 2px solid #ecf0f1;&quot; href=&quot;http://blog.segmentfault.com/young_ipython/1190000000534263&quot;&gt;协程篇&lt;/a&gt;中学习的吗？花了较长篇幅讲协程及从其子例程演变的过程。而greenlet就是python中实现Coroutine「协程」的一个基础库。前面我们了解了协程的相关概念及思想，但我们还不知道它在底层是怎样实现的。只知道它有个特别的地方，就是能够和进程、线程一样保存上下文，那协程的上下文是怎样保存的呢？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;源码初探&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject_HEAD&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_saved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top_frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recursion_depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakreflist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyGreenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面给出的是greenlet的结构体定义，有兴趣的可以去下一份源代码看看，里面也有很好的解释。&lt;/p&gt;

&lt;p&gt;这里我们主要了解一下关于堆栈的几个操作，从命名规则就可以找到我们想要的东西，就是它们几个了：&lt;code&gt;stack_start&lt;/code&gt;、&lt;code&gt;stack_stop&lt;/code&gt;、&lt;code&gt;stack_copy&lt;/code&gt;、&lt;code&gt;stack_saved&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其实仔细想想，你会发现非常的简单。假设有『函数A』和『函数B』，『函数A』进栈执行到一半的时候需要调用『函数B』，没事这个简单，我们可以将『函数B』进栈(图stack-01)。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:130px; height:190px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好了『函数B』进栈了，可它现在又想调用『函数A』了，怎么办？让『函数A』进栈(图stack-02)，这个其实就是普通的函数调用，此『函数A』并不是第一次进栈的那个『函数A』，而是重新在栈中创建的一个实例，该实例的数据并不是之前『函数A』的数据，可是我想要之前『函数A』的数据啊！所以这个方法并不能实现我们想要的切换。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:130px; height:245px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-04.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那怎样才能做到我们想要的呢？很简单，既然『函数B』完成了当前的任务，它就应该退出来了，但并不是直接出栈，而是通过某种方式将现有的state给记录下来，方便下次用到的时候能够找到。怎么记录呢？这里就可以回到上面我们需要了解的几个栈操作了。&lt;/p&gt;

&lt;p&gt;首先，每个greenlet都有属于它们自己的&lt;code&gt;stack_start&lt;/code&gt;和&lt;code&gt;stack_stop&lt;/code&gt;，通过这两个可以找到你准备出栈的greenlet也就是『函数B』的所有数据，之后再调用&lt;code&gt;PyMem_Realloc&lt;/code&gt;这个方法，就可以在heap中创建一个内存空间用来存放『函数B』，地址为stack_copy，大小为stack_saved字节，通过这两个就可以定位到你存放的『函数B』的数据了(图stack-03)。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:575px; height:205px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-05.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后变成下面(图stack-04)这样了。这个时候，如果『函数A』执行完了想去执行『函数B』的时候，就按照这个流程再保存，然后再把刚才存放的『函数B』给复制到C栈中。因为已经知道了&lt;code&gt;stack_copy&lt;/code&gt;和&lt;code&gt;stack_saved&lt;/code&gt;，所以也就不怕找不到它了。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:250px; height:140px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-06.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个greenlet切换流程大概就是这个样子了，不过到了这里不知道大家会不会有些疑问，虽然保存了&lt;code&gt;stack_copy&lt;/code&gt;和&lt;code&gt;stack_saved&lt;/code&gt;，但是『函数B』已经出栈了，不是就没有这个对象了吗？那这两个参数是由谁来保存呢？&lt;/p&gt;

&lt;p&gt;其实这个对象从来就没有被销毁，只要这个greenlet没有正常退出，它的对象就一直都存在着，因为Greenlet还维护着一个链表，它保存着所有没有彻底退出的greenlet对象，『函数B』出栈并不是完全退出了，只是不参与这次行动。具体的细节就要等到下一篇或者下下篇的源码剖析来讲解了。&lt;/p&gt;

&lt;p&gt;因为最近工作比较忙，换了一个部门，加上之前对源码理解不够，也就不敢随便发表。当然现在发表的也不敢说绝对正确，这些仅仅是我个人的理解，欢迎大神来指正。&lt;/p&gt;

</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent1.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent1.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— 协程</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在学习gevent之前，你肯定要知道你学的这个东西是什么。&lt;/p&gt;

&lt;h3 id=&quot;gevent&quot;&gt;&lt;strong&gt;官方描述gevent&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.&lt;/p&gt;

&lt;p&gt;翻译：gevent是一个基于协程的Python网络库。我们先理解这句，也是这次学习的重点——&lt;strong&gt;协程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;wiki&quot;&gt;&lt;strong&gt;wiki描述协程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;与子例程一样，协程也是一种程序组件&lt;/strong&gt;。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。子例程的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次；协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。协程允许多个入口点，可以在指定位置挂起和恢复执行。&lt;/p&gt;

&lt;p&gt;没看懂？没关系，我也没看懂，不过算是有点线索：&lt;strong&gt;子例程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;子例程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;过程有两种，一种叫子例程（Subroutine），通常叫Sub；另一种叫函数（Function）。底层实现机制是一样的，区别在于，Sub只执行操作，没有返回值；Function不但执行操作，并且有返回值。用过VB的应该会比较清楚这点。（原谅我用了百度百科）说到底子例程就是过程，我们一般叫它函数。&lt;/p&gt;

&lt;p&gt;说到函数，我就想吐槽了，不明白为什么要叫函数。很多时候我们写一个函数是为了封装、模块化某个功能，它是一个功能、或者说是一个过程。因为它包含的是类似于流程图那样的具体逻辑，先怎样做，然后怎样做；如果遇到A情况则怎样，如果遇到B情况又怎样。个人觉得还是叫过程比较好，叫做函数就让人很纠结了，难道因为回归到底层还是计算问题，出于数学的角度把它称为函数？这个略坑啊！为了符合大家的口味，我还是称之为函数好了（其实我也习惯叫函数了%&amp;gt;_&amp;lt;%）。&lt;/p&gt;

&lt;p&gt;讲到函数，我们就往底层深入一点，看看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;a start&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;a end&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;b start&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;b end&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;c start&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;c end&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于这样的结果大家肯定不会意外的。每当函数被调用，就会在栈中开辟一个栈空间，调用结束后再回收该空间。&lt;/p&gt;

&lt;p&gt;假设一个这样的场景：有个讲台，每个人都可以上去发表言论，但是每次讲台只能站一个人。现在a在上面演讲，当他说到“大家好！”的时候，b有个紧急通知要告诉大家，所以a就先下来让b讲完通知，然后a再上讲台继续演讲。如果用函数的思想模拟这个问题，堆栈示意图是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:461px; height:172px;&quot; src=&quot;http://young-py.github.io/imgs/gevent0-01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家会不会发现问题，就是b通知完a继续演讲都要重新开始。因为函数在重新调用的时候，它的局部变量是会被重置的，对于之前他说的那句“大家好”，他是不会记得的（可能a的记性不好）。那有没有什么办法可以不让他重复，而是在打断之后继续呢？很简单，在他走下讲台之前记住当前说过的话。表现在函数中就是在退出之前，保存该函数的局部变量，方便在重新进入该函数的时候，能够从之前的局部变量开始继续执行。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;升级版&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果你有一段代码生产数据，另外一段代码消费数据，哪个应该是调用者，哪个应该是被调用者？&lt;/p&gt;

&lt;p&gt;例如：生产者——消费者问题。假设有两个函数producer和consumer，缓冲区的大小为1，当缓冲区满了，producer调用consumer，当缓冲区空了，consumer调用producer，但是这样的函数互相调用会出什么问题？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;生产一个&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;消费一个&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;producer生产一个，缓冲区满了，consumer消费一个，缓冲区空了，producer生产一个，如此循环。会看到下面这样的图：&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:402px; height:229px;&quot; src=&quot;http://young-py.github.io/imgs/gevent0-02.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看起来好像不错，感觉两个函数协调运行的很好，很好的解决了生产者——消费者问题。如果真有这么好也就不会有协程的存在了，仔细分析会有两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无限次数的函数嵌套调用，而没有函数返回，会有什么样的后果？&lt;/li&gt;
  &lt;li&gt;两个函数貌似协调有序的工作，你来我往，但每次执行的都是同一个函数实例吗？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先，上面的伪代码示例是一个无限的函数嵌套调用，没有函数返回来释放栈，栈的空间不断的在增长，直到溢出，程序崩溃。然后，看起来两个函数协调有序，事实上操作的都不是同一个实例对象，不知道下面的图能否看懂。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:559px; height:251px;&quot; src=&quot;http://young-py.github.io/imgs/gevent0-03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那什么东西有这样的能力呢？我们很快就可以想到进程、线程，但是你真的想使用进程、线程如此重量级的东西在这么简单的程序上吗？野蛮的抢占式机制和笨重的上下文切换！&lt;/p&gt;

&lt;p&gt;还有一种程序组件，那就是协程。它能保留上一次调用时的状态，每次重新进入该过程的时候，就相当于回到上一次离开时所处逻辑流的位置。协程的起始处是第一个入口点，&lt;strong&gt;在协程里，返回点之后是接下来的入口点&lt;/strong&gt;。协程的生命期完全由他们的使用的需要决定。每个协程在用yield命令向另一个协程交出控制时都尽可能做了更多的工作，放弃控制使得另一个协程从这个协程停止的地方开始，接下来的每次协程被调用时，都是从协程返回（或yield）的位置接着执行。&lt;/p&gt;

&lt;p&gt;从上面这些你就可以知道其实协程是模拟了多线程（或多进程）的操作，多线程在切换的时候都会有一个上下文切换，在退出的时候将现场保存起来，等到下一次进入的时候从保存的现场开始，继续执行。&lt;/p&gt;

&lt;p&gt;看下协程是怎样实现的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Produced: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Consumed: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们一直都在大谈协程是什么样一个东西，却从没有提起协程用来干嘛，这个其实大家分析一下就能够知道。从上面的生产者——消费者问题应该能看出，它分别有两个任务，假设交给两个人去执行，但每次只能允许一个人行动。当缓冲区满的时候，生产者是出于等待状态的，这个时候可以将执行任务的权利转交给消费者，当缓冲区空得时候，消费者是出于等待状态的，这个时候可以将执行任务的权利转交给生产者，是不是很容易联想到&lt;strong&gt;多任务切换&lt;/strong&gt;？然后想到&lt;strong&gt;线程&lt;/strong&gt;？最后想到&lt;strong&gt;高并发&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;但同学们又会问，既然有了线程为什么还要协程呢？因为线程是系统级别的，在做切换的时候消耗是特别大的，具体为什么这么大等我研究好了再告诉你；同时线程的切换是由CPU决定的，可能你刚好执行到一个地方的时候就要被迫终止，这个时候你需要用各种措施来保证你的数据不出错，所以线程对于数据安全的操作是比较复杂的。而协程是用户级别的切换，且切换是由自己控制，不受外力终止。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;协程其实模拟了人类活动的一种过程。例如：你准备先写文档，然后修复bug。这时候接到电话说这个bug很严重，必须立即修复（可以看作CPU通知）。于是你暂停写文档，开始去填坑，终于你把坑填完了，你回来写文档，这个时候你肯定是接着之前写的文档继续，难道你要把之前写的给删了，重新写？这就是协程。那如果是子例程呢？那你就必须重新写了，因为退出之后，栈帧就会被弹出销毁，再次调用就是开辟新的栈空间了。&lt;/p&gt;

&lt;p&gt;总结：协程就是用户态下的线程，是人们在有了进程、线程之后仍觉得效率不够，而追求的又一种高并发解决方案。为什么说是用户态，是因为操作系统并不知道它的存在，它是由程序员自己控制、互相协作的让出控制权而不是像进程、线程那样由操作系统调度决定是否让出控制权。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 May 2014 21:34:03 +0800</pubDate>
        <link>/gevent/2014/05/08/gevent0.html</link>
        <guid isPermaLink="true">/gevent/2014/05/08/gevent0.html</guid>
      </item>
    
  </channel>
</rss>
