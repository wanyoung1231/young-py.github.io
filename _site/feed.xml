<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小乌龟 の blog</title>
    <description>关于Python及生活随记</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>使用pip安装python包</title>
        <description>&lt;p&gt;大多数的Python包是通过&lt;strong&gt;pip&lt;/strong&gt;程序安装的，在创建虚拟环境的时候virtualenv会自动添加进去。当一个虚拟环境被激活后，pip程序的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：如果你使用pyvenv创建虚拟环境在Python 3.3中，则必须手动安装pip。安装指令在pip网站上可以找到。在Python 3.4下，pyvenv会自动安装pip。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装Flask到虚拟环境中，使用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ pip install flask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个命令，Flask和它的依赖集都会安装到虚拟环境中。你可以验证Flask是否正确安装通过启动Python解释器并试着导入它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ python
&amp;gt;&amp;gt;&amp;gt; import flask
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有出现错误，祝贺你：你可以准备进入下一章节，接着你就可以写你的第一个web应用程序了。&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Aug 2014 00:55:38 +0800</pubDate>
        <link>/flask/2014/08/17/flask-1-2.html</link>
        <guid isPermaLink="true">/flask/2014/08/17/flask-1-2.html</guid>
      </item>
    
      <item>
        <title>使用虚拟环境</title>
        <description>&lt;p&gt;安装&lt;strong&gt;Flask&lt;/strong&gt;最方便的方法就是使用虚拟环境。虚拟环境是在Python解释器上的一个私有复制，你可以在一个隔绝的环境下安装packages，不会影响到你系统中全局的Python解释器。&lt;/p&gt;

&lt;p&gt;虚拟环境非常有用，因为它可以防止系统出现包管理混乱和版本冲突的问题。为每个应用程序创建一个虚拟环境可以确保应用程序只能访问它们自己使用的包，从而全局解释器只作为一个源且依然整洁干净，更多的虚拟环境可以被创建。另一个好处是，虚拟环境不需要管理员权限。&lt;/p&gt;

&lt;p&gt;虚拟环境由第三方程序&lt;strong&gt;virtualenv&lt;/strong&gt;创建。检查在你的系统中是否已经安装，可以输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你得到一个错误，你需要安装该程序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Python 3.3增加了本地支持的虚拟环境通过venv模块和pyvenv命令。pyenv可以用来代替virtualenv，但是注意通过pyvenv创建的虚拟环境不包含pip，需要手动安装。这个限制会在Python 3.4中移除，到时候pyvenv可以当作完整的virtualenv替代品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大多数Linux发行版都提供一个virtualenv包。例如，Ubuntu用户就可以使用以下命令进行安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Mac OSX，你可以使用easy_install安装virtualenv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Microsoft Windows或者是任何没有提供官方virtualenv包的操作系统，接下来你会有一个稍微复杂的安装过程。&lt;/p&gt;

&lt;p&gt;使用你的web浏览器，导航到&lt;a href=&quot;https://bitbucket.org/pypa/setuptools&quot;&gt;https://bitbucket.org/pypa/setuptools&lt;/a&gt;，setuptools安装程序的主页，找到链接下载一个叫ez_setup.py安装程序脚本。保存这个文件到你电脑的临时文件夹中，然后在那个目录下运行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python ez_setup.py
$ easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：前一个命令必须由管理员权限的账户发出。在Microsoft Windows，以管理员身份选项运行命令提示符窗口。在基于Unix的系统中，两个安装命令前面必须加上&lt;code&gt;sudo&lt;/code&gt;或作为&lt;code&gt;root&lt;/code&gt;用户执行。一旦安装完毕，virtualenv程序可以通过普通账户执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你需要创建文件夹用来组织从GitHub仓库中获取的示例代码。在十三页中《如何使用示例代码》讨论的那样，最方便的方法就是使用Git客户端直接从Github中检出代码。下面的命令从GitHub中下载示例代码并初始化应用程序文件目录为“1a”版本，初始版本的应用程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/miguelgrinberg/flasky.git
$ cd flasky
$ git checkout 1a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步就是使用virtualenv命令创建Python虚拟环境到flasky文件夹中。这个命令有一个需要的参数：虚拟环境的名称。一个指定名称的文件夹和在里面的、与虚拟环境相关的所有文件会在当前目录下被创建。一般给虚拟环境约定命名为venv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv venv
New python executable in venv/bin/python2.7
Also creating executable in venv/bin/python
Installing setuptools............done.
Installing pip...............done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你有一个venv文件夹在flasky文件夹里面和一个全新的虚拟环境，包含一个私有的Python解释器。使用虚拟环境的时候，你必须“激活”它。如果你是使用bash命令行工具(Linux和Mac OSX用户)，你可以使用这个命令激活虚拟环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是使用Microsoft Windows，激活命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ venv\Scripts\activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当虚拟环境被激活了，Python解释器的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中，但是这个改动并不是永久的；它只影响当前命令会话。提醒一下，你激活了虚拟环境，该激活命令会将环境的名称包含在命令提示符里面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在虚拟环境中完成工作并想回到全局Python解释器，在命令提示符中输入&lt;code&gt;deactivate&lt;/code&gt;就可以了。&lt;/p&gt;

</description>
        <pubDate>Sat, 16 Aug 2014 19:32:38 +0800</pubDate>
        <link>/flask/2014/08/16/flask-1-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/16/flask-1-1.html</guid>
      </item>
    
      <item>
        <title>Flask Web Development 第一部分 Flask介绍 目录</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1、安装&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使用虚拟环境

使用pip安装python包
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2、基本应用程序结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;初始化

Routes和view函数

服务启动

一个完整的应用程序

请求-响应周期

    应用程序和请求上下文

    请求派发

    请求hooks

    响应

Flask扩展

命令行选项和Flask-Script
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3、模板&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;jinja2木板引擎

    渲染模板

    变量

    控制结构

集成在Flask-Bootstrap中的Twitter Bootstrap

自定义错误页面

链接

静态文件

Flask-Moment中的本地化日期和时间
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;web&quot;&gt;4、Web表单&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;跨站请求伪造(CSRF)保护

表单类

HTML渲染的表单

View函数中的表单操作

重定向和用户sessions

Message闪现
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;5、数据库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SQL数据库

NoSQL数据库

SQL还是NoSQL

python数据库框架

使用Flask-SQLAlchemy管理数据库

模型定义

关系

数据库操作

    创建表

    插入行

    修改行

    删除行

    返回行

View函数中数据库的使用

与python shell的集成

使用Flask-Migrate迁移数据库

    创建迁移仓库

    创建迁移脚本

    更新数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;6、邮箱&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;使用Flask-Mail作为邮件支持

    使用python shell发送邮件

    集成邮件到应用程序

    发送异步邮件
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;7、大型应用程序结构&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;项目结构

配置选项

应用程序包

    使用一个应用程序工厂

    在Blueprint中实现应用程序的功能

启动脚本

所需文件

单元测试

数据库启动
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 15 Aug 2014 18:35:03 +0800</pubDate>
        <link>/flask/2014/08/15/catalog.html</link>
        <guid isPermaLink="true">/flask/2014/08/15/catalog.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从gevent官方描述中又提到：that uses greenlet to provide a high-level synchronous API.&lt;/p&gt;

&lt;p&gt;翻译：使用greenlet来提供高级同步API。这次学习的主要内容——&lt;strong&gt;greenlet&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;greenlet&quot;&gt;&lt;strong&gt;Greenlet&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;greenlet是python中实现我们所谓的”Coroutine(协程)”的一个基础库。前面我们知道了协程是个什么样的东西，但是我们还不知道协程在底层是怎样实现的。在协程篇我们知道，子例程是协程的特例。我们花了比较长的篇幅讲述协程是怎么从子例程中演变过来的。我们知道协程有个特别的地方，就是它能够和进程、线程一样保存上下文。这个上下文是怎样保存的呢？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;源码分析&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject_HEAD&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_saved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top_frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recursion_depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakreflist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyGreenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent1.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent1.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— 协程</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在学习gevent之前，你肯定要知道你学的这个东西是什么。&lt;/p&gt;

&lt;h3 id=&quot;gevent&quot;&gt;&lt;strong&gt;官方描述gevent&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.&lt;/p&gt;

&lt;p&gt;翻译：gevent是一个基于协程的Python网络库。我们先理解这句，也是这次学习的重点——&lt;strong&gt;协程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;wiki&quot;&gt;&lt;strong&gt;wiki描述协程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;与子例程一样，协程也是一种程序组件&lt;/strong&gt;。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。子例程的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次；协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。协程允许多个入口点，可以在指定位置挂起和恢复执行。&lt;/p&gt;

&lt;p&gt;没看懂？没关系，我也没看懂，不过算是有点线索：&lt;strong&gt;子例程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;子例程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;过程有两种，一种叫子例程（Subroutine），通常叫Sub；另一种叫函数（Function）。底层实现机制是一样的，区别在于，Sub只执行操作，没有返回值；Function不但执行操作，并且有返回值。用过VB的应该会比较清楚这点。（原谅我用了百度百科）&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;push b&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;pop a&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;pop b&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;push a&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每当子例程被调用时，都会生成一个新的子例程实例，表现在底层就是在栈中开辟新的栈空间。执行从被调用子例程的起始处开始，子例程的起始处是唯一的入口点，一旦退出即完成了子例程的执行，该子例程的实例就会从栈中弹出。它的生命周期遵循后进先出，最后一个被调用的子例程最先返回。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;升级版&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;组织构建一个大型程序通常是非常艰难的工作。经常会碰到这样一种特殊问题：如果你有一段代码生产数据，另外一段代码消费数据，哪个应该是调用者，哪个应该是被调用者？&lt;/p&gt;

&lt;p&gt;例如：生产者 —— 消费者问题，先抛开进程、线程等实现方法。假设有两个子例程producer和consumer，当缓冲区满了，producer调用consumer，当缓冲区空了，consumer调用producer，但是这样的子例程互相调用会出什么问题？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们知道每当子例程被调用时，都会生成一个新的子例程实例，在栈中开辟新的空间。这样无限次数的调用，很快就会栈空间不足造成堆栈溢出错误。因为子例程的本身设计就是不完美的，子例程每次退出都会清空该子例程实例的栈帧，每次进入都是重新开始。子例程不具备保存退出点和局部状态的能力。&lt;/p&gt;

&lt;p&gt;那什么东西有这样的能力呢？我们很快就可以想到进程、线程，但是你真的想使用进程、线程如此重量级的东西在这么简单的程序上吗？野蛮的抢占式机制和笨重的上下文切换！&lt;/p&gt;

&lt;p&gt;协程就是拥有这种能力的神器。它能保留上一次调用时的状态，每次重新进入该过程的时候，就相当于回到上一次离开时所处逻辑流的位置。协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。协程的生命期完全由他们的使用的需要决定。每个协程在用yield命令向另一个协程交出控制时都尽可能做了更多的工作，放弃控制使得另一个协程从这个协程停止的地方开始，接下来的每次协程被调用时，都是从协程返回（或yield）的位置接着执行。&lt;/p&gt;

&lt;p&gt;从上面这些你就可以知道其实协程是模拟了多线程（或多进程）的操作，多线程在切换的时候都会有一个上下文切换，在退出的时候将现场保存起来，等到下一次进入的时候从保存的现场开始，继续执行。&lt;/p&gt;

&lt;p&gt;看下协程是怎样实现的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Produced: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Consumed: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;协程其实模拟了人类活动的一种过程。例如：你准备先写文档，然后修复bug。这时候接到电话说这个bug很严重，必须立即修复（可以看作CPU通知）。于是你暂停写文档，开始去填坑，终于你把坑填完了，你回来写文档，这个时候你肯定是接着之前写的文档继续，难道你要把之前写的给删了，重新写？这就是协程。那如果是子例程呢？那你就必须重新写了，因为退出之后，栈帧就会被弹出销毁，再次调用就是开辟新的栈空间了。&lt;/p&gt;

&lt;p&gt;总结出：协程就是用户态下的线程，是人们在有了进程、线程之后仍觉得效率不够，而追求的又一种高并发解决方案。为什么说是用户态，是因为操作系统并不知道它的存在，它是由程序员自己控制、互相协作的让出控制权而不是像进程、线程那样由操作系统调度决定是否让出控制权。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 May 2014 21:34:03 +0800</pubDate>
        <link>/gevent/2014/05/08/gevent0.html</link>
        <guid isPermaLink="true">/gevent/2014/05/08/gevent0.html</guid>
      </item>
    
  </channel>
</rss>
