<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小乌龟 の blog</title>
    <description>关于Python及生活随记</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>初始化</title>
        <description>&lt;p&gt;在这章，你将学到Flask应用程序的不同部分。同时，你将编写和运行你的第一个Flask web应用程序。&lt;/p&gt;

&lt;p&gt;所有的Flask应用程序都必须创建一个_应用程序实例_。使用web服务器网关接口协议将所有从客户端接收的请求传递给这个对象处理。这个应用程序实例是&lt;strong&gt;Flask&lt;/strong&gt;类的一个对象，通常使用下面的方式创建：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的&lt;code&gt;__name__&lt;/code&gt;变量是正确的值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Aug 2014 01:26:38 +0800</pubDate>
        <link>/flask/2014/08/19/flask-2-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/19/flask-2-1.html</guid>
      </item>
    
      <item>
        <title>使用pip安装python包</title>
        <description>&lt;p&gt;大多数的Python包是通过&lt;strong&gt;pip&lt;/strong&gt;程序安装的，在创建虚拟环境的时候virtualenv会自动添加进去。当一个虚拟环境被激活后，pip程序的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：如果你使用pyvenv创建虚拟环境在Python 3.3中，则必须手动安装pip。安装指令在pip网站上可以找到。在Python 3.4下，pyvenv会自动安装pip。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装Flask到虚拟环境中，使用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ pip install flask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个命令，Flask和它的依赖集都会安装到虚拟环境中。你可以验证Flask是否正确安装通过启动Python解释器并试着导入它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ python
&amp;gt;&amp;gt;&amp;gt; import flask
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要安装的包比较多的时候，这样做会比较繁琐，我们还有一键安装的方法。首先新建一个文本文件，如：&lt;code&gt;requirements.txt&lt;/code&gt;，然后将你需要安装的包名保存到该文件中(根据自己的需要)，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Babel==1.3
Flask==0.10.1
Flask-Login==0.2.7
Flask-SQLAlchemy==1.0
Flask-WTF==0.9.3
Jinja2==2.7.1
SQLAlchemy==0.8.2
WTForms==1.0.5
Werkzeug==0.9.4
psycopg2==2.5.1
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你只需要输入以下命令，所有需要的包就可以全部安装好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有出现错误，祝贺你：你可以准备进入下一章节，接着你就可以写你的第一个web应用程序了。&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Aug 2014 00:55:38 +0800</pubDate>
        <link>/flask/2014/08/17/flask-1-2.html</link>
        <guid isPermaLink="true">/flask/2014/08/17/flask-1-2.html</guid>
      </item>
    
      <item>
        <title>使用虚拟环境</title>
        <description>&lt;p&gt;安装&lt;strong&gt;Flask&lt;/strong&gt;最方便的方法就是使用虚拟环境。虚拟环境是在Python解释器上的一个私有复制，你可以在一个隔绝的环境下安装packages，不会影响到你系统中全局的Python解释器。&lt;/p&gt;

&lt;p&gt;虚拟环境非常有用，因为它可以防止系统出现包管理混乱和版本冲突的问题。为每个应用程序创建一个虚拟环境可以确保应用程序只能访问它们自己使用的包，从而全局解释器只作为一个源且依然整洁干净，更多的虚拟环境可以被创建。另一个好处是，虚拟环境不需要管理员权限。&lt;/p&gt;

&lt;p&gt;虚拟环境由第三方程序&lt;strong&gt;virtualenv&lt;/strong&gt;创建。检查在你的系统中是否已经安装，可以输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你得到一个错误，你需要安装该程序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Python 3.3增加了本地支持的虚拟环境通过venv模块和pyvenv命令。pyenv可以用来代替virtualenv，但是注意通过pyvenv创建的虚拟环境不包含pip，需要手动安装。这个限制会在Python 3.4中移除，到时候pyvenv可以当作完整的virtualenv替代品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大多数Linux发行版都提供一个virtualenv包。例如，Ubuntu用户就可以使用以下命令进行安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Mac OSX，你可以使用easy_install安装virtualenv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Microsoft Windows或者是任何没有提供官方virtualenv包的操作系统，接下来你会有一个稍微复杂的安装过程。&lt;/p&gt;

&lt;p&gt;使用你的web浏览器，导航到&lt;a href=&quot;https://bitbucket.org/pypa/setuptools&quot;&gt;https://bitbucket.org/pypa/setuptools&lt;/a&gt;，setuptools安装程序的主页，找到链接下载一个叫ez_setup.py安装程序脚本。保存这个文件到你电脑的临时文件夹中，然后在那个目录下运行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python ez_setup.py
$ easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：前一个命令必须由管理员权限的账户发出。在Microsoft Windows，以管理员身份选项运行命令提示符窗口。在基于Unix的系统中，两个安装命令前面必须加上&lt;code&gt;sudo&lt;/code&gt;或作为&lt;code&gt;root&lt;/code&gt;用户执行。一旦安装完毕，virtualenv程序可以通过普通账户执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你需要创建文件夹用来组织从GitHub仓库中获取的示例代码。在十三页中《如何使用示例代码》讨论的那样，最方便的方法就是使用Git客户端直接从Github中检出代码。下面的命令从GitHub中下载示例代码并初始化应用程序文件目录为“1a”版本，初始版本的应用程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/miguelgrinberg/flasky.git
$ cd flasky
$ git checkout 1a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步就是使用virtualenv命令创建Python虚拟环境到flasky文件夹中。这个命令有一个需要的参数：虚拟环境的名称。一个指定名称的文件夹和在里面的、与虚拟环境相关的所有文件会在当前目录下被创建。一般给虚拟环境约定命名为venv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv venv
New python executable in venv/bin/python2.7
Also creating executable in venv/bin/python
Installing setuptools............done.
Installing pip...............done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你有一个venv文件夹在flasky文件夹里面和一个全新的虚拟环境，包含一个私有的Python解释器。使用虚拟环境的时候，你必须“激活”它。如果你是使用bash命令行工具(Linux和Mac OSX用户)，你可以使用这个命令激活虚拟环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是使用Microsoft Windows，激活命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ venv\Scripts\activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当虚拟环境被激活了，Python解释器的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中，但是这个改动并不是永久的；它只影响当前命令会话。提醒一下，你激活了虚拟环境，该激活命令会将环境的名称包含在命令提示符里面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在虚拟环境中完成工作并想回到全局Python解释器，在命令提示符中输入&lt;code&gt;deactivate&lt;/code&gt;就可以了。&lt;/p&gt;

</description>
        <pubDate>Sat, 16 Aug 2014 19:32:38 +0800</pubDate>
        <link>/flask/2014/08/16/flask-1-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/16/flask-1-1.html</guid>
      </item>
    
      <item>
        <title>Flask Web Development 第一部分 Flask介绍 目录</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1、安装&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;使用虚拟环境

使用pip安装python包
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2、基本应用程序结构&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;初始化

Routes和view函数

服务启动

一个完整的应用程序

请求-响应周期

    应用程序和请求上下文

    请求派发

    请求hooks

    响应

Flask扩展

命令行选项和Flask-Script
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3、模板&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;jinja2木板引擎

    渲染模板

    变量

    控制结构

集成在Flask-Bootstrap中的Twitter Bootstrap

自定义错误页面

链接

静态文件

Flask-Moment中的本地化日期和时间
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;web&quot;&gt;4、Web表单&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;跨站请求伪造(CSRF)保护

表单类

HTML渲染的表单

View函数中的表单操作

重定向和用户sessions

Message闪现
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;5、数据库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SQL数据库

NoSQL数据库

SQL还是NoSQL

python数据库框架

使用Flask-SQLAlchemy管理数据库

模型定义

关系

数据库操作

    创建表

    插入行

    修改行

    删除行

    返回行

View函数中数据库的使用

与python shell的集成

使用Flask-Migrate迁移数据库

    创建迁移仓库

    创建迁移脚本

    更新数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;6、邮箱&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;使用Flask-Mail作为邮件支持

    使用python shell发送邮件

    集成邮件到应用程序

    发送异步邮件
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;7、大型应用程序结构&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;项目结构

配置选项

应用程序包

    使用一个应用程序工厂

    在Blueprint中实现应用程序的功能

启动脚本

所需文件

单元测试

数据库启动
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 15 Aug 2014 18:35:03 +0800</pubDate>
        <link>/flask/2014/08/15/catalog.html</link>
        <guid isPermaLink="true">/flask/2014/08/15/catalog.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet源码剖析</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/imgs/yyzt3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent2.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent2.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gevent文档：that uses greenlet to provide a high-level synchronous API.&lt;/p&gt;

&lt;p&gt;意思是：使用&lt;strong&gt;greenlet&lt;/strong&gt;来提供&lt;strong&gt;高级同步API&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那greenlet又是怎样一种机制呢？这个后面会稍微简单的讲一下原理，不过在后续的几篇会着重分析它的源码。在开始之前先看看提到的几个关键字『高级』、『同步』，高级不高级暂时还不知道，毕竟在实际生产环境中才看得到效果。而同步这个概念，不知道大家理解深不深刻，总之我当初理解不是很深刻，所以遇到了就聊聊呗！&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;不明白为什么会叫同步，总是让我有一种错觉，让我联想到的第一个词汇就是同时进行。不知道大家是不是和我一样，至少我看到同步是不会去想到它的正确意思。我曾一度怀疑是不是翻译错了，但是在质疑别人错之前，应该先质疑一下自己。所以我开始怀疑我的语文没学好，然后我去查了一下汉语词典，结果就悲剧了，我已经开始怀疑我的人生了。 %&amp;gt;_&amp;lt;%&lt;/p&gt;

&lt;p&gt;同步：指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;《光明日报》1984.6.2：“城市改革的步子要加快，要从解决国家与企业、企业与职工的关系入手，把适合于当前情况的各项改革措施初步配起套来，同步进行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从上面引用的话应该可以看出，国家与企业、企业与职工，都是两个相对的关系，有着各自的利益。但是他们必须合作才能完成一个共同目标，例如买票看电影。这个场景有两个动作需要完成，一个出票、一个买票，只有出票才能买票，并且这个买票的人还只能傻等，不能做其他事。&lt;/p&gt;

&lt;p&gt;同步真心不是同时进行，所以还是要多读书啊！尤其是语文！&lt;/p&gt;

&lt;p&gt;为什么这里会讲到同步呢？其实不讲也是可以的，和理解greenlet原理没有多大关系，但是和理解gevent的特性有那么点关系，因为听别人说gevent能够让你用这种同步的代码写出异步的感觉，同步的代码好理解也好处理。我没有验证过，所以我也不知道，真正的原因是感觉这个概念很容易混淆，所以就来讲讲了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;greenlet&quot;&gt;&lt;strong&gt;Greenlet&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;还记得在&lt;a style=&quot;border-bottom: 2px solid #ecf0f1;&quot; href=&quot;http://blog.segmentfault.com/young_ipython/1190000000534263&quot;&gt;协程篇&lt;/a&gt;中学习的吗？花了较长篇幅讲协程及从其子例程演变的过程。而greenlet就是python中实现Coroutine「协程」的一个基础库。前面我们了解了协程的相关概念及思想，但我们还不知道它在底层是怎样实现的。只知道它有个特别的地方，就是能够和进程、线程一样保存上下文，那协程的上下文是怎样保存的呢？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;源码初探&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject_HEAD&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_saved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top_frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recursion_depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakreflist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyGreenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面给出的是greenlet的结构体定义，有兴趣的可以去下一份源代码看看，里面也有很好的解释。&lt;/p&gt;

&lt;p&gt;这里我们主要了解一下关于堆栈的几个操作，从命名规则就可以找到我们想要的东西，就是它们几个了：&lt;code&gt;stack_start&lt;/code&gt;、&lt;code&gt;stack_stop&lt;/code&gt;、&lt;code&gt;stack_copy&lt;/code&gt;、&lt;code&gt;stack_saved&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其实仔细想想，你会发现非常的简单。假设有『函数A』和『函数B』，『函数A』进栈执行到一半的时候需要调用『函数B』，没事这个简单，我们可以将『函数B』进栈(图stack-01)。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:130px; height:190px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好了『函数B』进栈了，可它现在又想调用『函数A』了，怎么办？让『函数A』进栈(图stack-02)，这个其实就是普通的函数调用，此『函数A』并不是第一次进栈的那个『函数A』，而是重新在栈中创建的一个实例，该实例的数据并不是之前『函数A』的数据，可是我想要之前『函数A』的数据啊！所以这个方法并不能实现我们想要的切换。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:130px; height:245px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-04.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那怎样才能做到我们想要的呢？很简单，既然『函数B』完成了当前的任务，它就应该退出来了，但并不是直接出栈，而是通过某种方式将现有的state给记录下来，方便下次用到的时候能够找到。怎么记录呢？这里就可以回到上面我们需要了解的几个栈操作了。&lt;/p&gt;

&lt;p&gt;首先，每个greenlet都有属于它们自己的&lt;code&gt;stack_start&lt;/code&gt;和&lt;code&gt;stack_stop&lt;/code&gt;，通过这两个可以找到你准备出栈的greenlet也就是『函数B』的所有数据，之后再调用&lt;code&gt;PyMem_Realloc&lt;/code&gt;这个方法，就可以在heap中创建一个内存空间用来存放『函数B』，地址为stack_copy，大小为stack_saved字节，通过这两个就可以定位到你存放的『函数B』的数据了(图stack-03)。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:575px; height:205px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-05.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后变成下面(图stack-04)这样了。这个时候，如果『函数A』执行完了想去执行『函数B』的时候，就按照这个流程再保存，然后再把刚才存放的『函数B』给复制到C栈中。因为已经知道了&lt;code&gt;stack_copy&lt;/code&gt;和&lt;code&gt;stack_saved&lt;/code&gt;，所以也就不怕找不到它了。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:250px; height:140px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-06.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个greenlet切换流程大概就是这个样子了，不过到了这里不知道大家会不会有些疑问，虽然保存了&lt;code&gt;stack_copy&lt;/code&gt;和&lt;code&gt;stack_saved&lt;/code&gt;，但是『函数B』已经出栈了，不是就没有这个对象了吗？那这两个参数是由谁来保存呢？&lt;/p&gt;

&lt;p&gt;其实这个对象从来就没有被销毁，只要这个greenlet没有正常退出，它的对象就一直都存在着，因为Greenlet还维护着一个链表，它保存着所有没有彻底退出的greenlet对象，『函数B』出栈并不是完全退出了，只是不参与这次行动。具体的细节就要等到下一篇或者下下篇的源码剖析来讲解了。&lt;/p&gt;

&lt;p&gt;因为最近工作比较忙，换了一个部门，加上之前对源码理解不够，也就不敢随便发表。当然现在发表的也不敢说绝对正确，这些仅仅是我个人的理解，欢迎大神来指正。&lt;/p&gt;

</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent1.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent1.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— 协程</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在学习gevent之前，你肯定要知道你学的这个东西是什么。&lt;/p&gt;

&lt;h3 id=&quot;gevent&quot;&gt;&lt;strong&gt;官方描述gevent&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.&lt;/p&gt;

&lt;p&gt;翻译：gevent是一个基于协程的Python网络库。我们先理解这句，也是这次学习的重点——&lt;strong&gt;协程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;wiki&quot;&gt;&lt;strong&gt;wiki描述协程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;与子例程一样，协程也是一种程序组件&lt;/strong&gt;。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。子例程的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次；协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。协程允许多个入口点，可以在指定位置挂起和恢复执行。&lt;/p&gt;

&lt;p&gt;没看懂？没关系，我也没看懂，不过算是有点线索：&lt;strong&gt;子例程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;子例程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;过程有两种，一种叫子例程（Subroutine），通常叫Sub；另一种叫函数（Function）。底层实现机制是一样的，区别在于，Sub只执行操作，没有返回值；Function不但执行操作，并且有返回值。用过VB的应该会比较清楚这点。（原谅我用了百度百科）&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;push b&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;pop a&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;pop b&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;push a&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每当子例程被调用时，都会生成一个新的子例程实例，表现在底层就是在栈中开辟新的栈空间。执行从被调用子例程的起始处开始，子例程的起始处是唯一的入口点，一旦退出即完成了子例程的执行，该子例程的实例就会从栈中弹出。它的生命周期遵循后进先出，最后一个被调用的子例程最先返回。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;升级版&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;组织构建一个大型程序通常是非常艰难的工作。经常会碰到这样一种特殊问题：如果你有一段代码生产数据，另外一段代码消费数据，哪个应该是调用者，哪个应该是被调用者？&lt;/p&gt;

&lt;p&gt;例如：生产者 —— 消费者问题，先抛开进程、线程等实现方法。假设有两个子例程producer和consumer，当缓冲区满了，producer调用consumer，当缓冲区空了，consumer调用producer，但是这样的子例程互相调用会出什么问题？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们知道每当子例程被调用时，都会生成一个新的子例程实例，在栈中开辟新的空间。这样无限次数的调用，很快就会栈空间不足造成堆栈溢出错误。因为子例程的本身设计就是不完美的，子例程每次退出都会清空该子例程实例的栈帧，每次进入都是重新开始。子例程不具备保存退出点和局部状态的能力。&lt;/p&gt;

&lt;p&gt;那什么东西有这样的能力呢？我们很快就可以想到进程、线程，但是你真的想使用进程、线程如此重量级的东西在这么简单的程序上吗？野蛮的抢占式机制和笨重的上下文切换！&lt;/p&gt;

&lt;p&gt;协程就是拥有这种能力的神器。它能保留上一次调用时的状态，每次重新进入该过程的时候，就相当于回到上一次离开时所处逻辑流的位置。协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。协程的生命期完全由他们的使用的需要决定。每个协程在用yield命令向另一个协程交出控制时都尽可能做了更多的工作，放弃控制使得另一个协程从这个协程停止的地方开始，接下来的每次协程被调用时，都是从协程返回（或yield）的位置接着执行。&lt;/p&gt;

&lt;p&gt;从上面这些你就可以知道其实协程是模拟了多线程（或多进程）的操作，多线程在切换的时候都会有一个上下文切换，在退出的时候将现场保存起来，等到下一次进入的时候从保存的现场开始，继续执行。&lt;/p&gt;

&lt;p&gt;看下协程是怎样实现的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Produced: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Consumed: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;协程其实模拟了人类活动的一种过程。例如：你准备先写文档，然后修复bug。这时候接到电话说这个bug很严重，必须立即修复（可以看作CPU通知）。于是你暂停写文档，开始去填坑，终于你把坑填完了，你回来写文档，这个时候你肯定是接着之前写的文档继续，难道你要把之前写的给删了，重新写？这就是协程。那如果是子例程呢？那你就必须重新写了，因为退出之后，栈帧就会被弹出销毁，再次调用就是开辟新的栈空间了。&lt;/p&gt;

&lt;p&gt;总结出：协程就是用户态下的线程，是人们在有了进程、线程之后仍觉得效率不够，而追求的又一种高并发解决方案。为什么说是用户态，是因为操作系统并不知道它的存在，它是由程序员自己控制、互相协作的让出控制权而不是像进程、线程那样由操作系统调度决定是否让出控制权。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 May 2014 21:34:03 +0800</pubDate>
        <link>/gevent/2014/05/08/gevent0.html</link>
        <guid isPermaLink="true">/gevent/2014/05/08/gevent0.html</guid>
      </item>
    
  </channel>
</rss>
