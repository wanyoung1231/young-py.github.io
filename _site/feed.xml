<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小乌龟 の blog</title>
    <description>关于Python及生活随记</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>gevent 学习笔记 —— greenlet源码剖析2</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt4.jpg&quot; alt=&quot;&quot; /&gt;
敬请期待。。。&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Oct 2014 04:10:25 +0800</pubDate>
        <link>/gevent/2014/10/16/gevent3.html</link>
        <guid isPermaLink="true">/gevent/2014/10/16/gevent3.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 基本应用程序结构（上）</title>
        <description>&lt;p&gt;在这一章，你将学习Flask应用程序不同部分。同时你将编写和运行你的第一个Flask web应用程序。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;1、初始化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在这章，你将学到Flask应用程序的不同部分。同时，你将编写和运行你的第一个Flask web应用程序。&lt;/p&gt;

&lt;p&gt;所有的Flask应用程序都必须创建一个 &lt;em&gt;应用程序实例&lt;/em&gt; 。使用web服务器网关接口协议将所有从客户端接收的请求传递给这个对象处理。这个应用程序实例就是&lt;strong&gt;Flask&lt;/strong&gt;类的一个对象，通常使用下面的方式创建：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的&lt;code&gt;__name__&lt;/code&gt;变量就是那个正确的、你需要传递的值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：对于Flask开发者来说，传给Flask应用程序构造函数的&lt;code&gt;name&lt;/code&gt;参数是比较容易弄混淆的。Flask使用这个参数来确定应用程序的根目录，这样以后可以相对这个路径来找到资源文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;稍后你可以看到更复杂的应用程序实例初始化，但是对于简单应用程序这些已经足够了。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;2、路由和视图函数&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;客户端例如web浏览器发送 &lt;em&gt;请求&lt;/em&gt; 给web服务，进而将它们发送给Flask应用程序实例。应用程序实例需要知道对于各个URL请求需要运行哪些代码，所以它给Python函数建立了一个URLs映射。这些在URL和函数之间建立联系的操作被称之为 &lt;em&gt;路由&lt;/em&gt; 。&lt;/p&gt;

&lt;p&gt;在Flask应程序中定义路由的最便捷的方式是通过显示定义在应用程序实例之上的&lt;code&gt;app.route&lt;/code&gt;装饰器，注册被装饰的函数来作为一个路由。下面的例子会演示怎样使用装饰器来申明一个路由：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：装饰器是Python语言的标准特性；它们可以以不同方式改变函数的行为。一个常见的模式是使用装饰器来注册函数作为一个事件处理程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在上一个示例给应用程序的根URL注册&lt;code&gt;index()&lt;/code&gt;函数作为事件的处理程序。如果这个应用程序被部署在服务器上并绑定了 &lt;em&gt;www.example.com&lt;/em&gt; 域名，然后在你的浏览器地址栏中输入 &lt;em&gt;http://www.example.com&lt;/em&gt; 将触发&lt;code&gt;index()&lt;/code&gt;来运行服务。客户端接收到的这个函数的返回值被称为 &lt;em&gt;响应&lt;/em&gt; 。如果客户端是web浏览器，响应则是显示给用户的文档。&lt;/p&gt;

&lt;p&gt;类似于&lt;code&gt;index()&lt;/code&gt;的函数被称作 &lt;em&gt;视图函数&lt;/em&gt; 。通过视图返回的响应可以是简单的HTML内容的字符串，但它也可以市更复杂的形式，正如您将看到的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：响应字符串嵌入在Python代码中导致代码难以掌控，在此只是介绍响应的概念。你将在第三章学习正确的方法来生成响应。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你注意到你每天使用的一些网站URLs如何形成的，你将会发现很多都有变量。例如，你的Facebook个人信息页的URL是 &lt;em&gt;http://www.facebook.com/&amp;lt;username&amp;gt;&lt;/em&gt; ，所以你的用户名是它的一部分。Flask在路由装饰器中使用特殊的语法支持这些类型的URLs。下面的示例定义了一个拥有动态名称组件的路由：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/user/&amp;lt;name&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用尖括号括起来的部分是动态的部分，所以任何URLs匹配到静态部分都将映射到这个路由。当视图函数被调用，Flask发送动态组件作为一个参数。在前面的示例的视图函数中，这个参数是用于生成一个个性的问候作为响应。&lt;/p&gt;

&lt;p&gt;在路由中动态组件默认为字符串，但是可以定义为其他类型。例如，路由&lt;code&gt;/user/&amp;lt;int:id&amp;gt;&lt;/code&gt;只匹配有一个整数在id动态段的URLs。Flask路由支持int、float和path。path同样是字符串类型，但并不认为斜杠是分隔符，而认为它们是动态组件的一部分。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;3、服务启动&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;应用程序实例有一个&lt;code&gt;run&lt;/code&gt;方法用于启动Flask集成的web服务：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;__name__ == &#39;__main__&#39;&lt;/code&gt;在此处使用是用于确保web服务已经启动当脚本被立即执行。当脚本被另一个脚本导入，它被看做父脚本将启动不同的服务，所以&lt;code&gt;app.run()&lt;/code&gt;调用会被跳过。&lt;/p&gt;

&lt;p&gt;一旦服务启动，它将进入循环等待请求并为之服务。这个循环持续到应用程序停止，例如通过按下&lt;code&gt;Ctrl-C&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有几个选项参数可以给&lt;code&gt;app.run()&lt;/code&gt;配置web服务的操作模式。在开发期间，可以很方便的开启debug模式，将激活 &lt;em&gt;debugger&lt;/em&gt; 和 &lt;em&gt;reloader&lt;/em&gt; 。这样做是通过传递debug为True来实现的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Flask提供的web服务并不用于生产环境。你将在十七章学习生产环境的web服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;&lt;strong&gt;一个完整的应用程序&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在上一节，你学习了Flask web应用程序的不同部分，现在是时候写一个了。整个 &lt;em&gt;hello.py&lt;/em&gt; 应用程序脚本只不过将前面描述的三个部分结合在一个文件中。应用程序示例2-1所示。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例2-1 hello.py：一个完整的Flask应用程序&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序的，你现在可以运行&lt;code&gt;git checkout 2a&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运行应用程序之前，请确保你在之前创建的虚拟环境已经是激活状态且已安装Flask。现在打开你的web浏览器并在地址栏输入 &lt;em&gt;http://127.0.0.1:5000/&lt;/em&gt; 。图像2-1显示连接到应用程序后的web浏览器。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask2-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图像2-1 hello.py Flask应用程序&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;然后输入以下命令启动应用程序：
    (venv) $ python hello.py
     * Running on http://127.0.0.1:5000/
     * Restarting with reloader&lt;/p&gt;

&lt;p&gt;如果你输入任何其他URL，应用程序将不知道如何操作它并且将返回错误代码404给浏览器——当你访问一个不存在的网页也会得到该错误。&lt;/p&gt;

&lt;p&gt;示例2-2所示应用程序的增强版添加了第二个动态路由。当你访问这个URI，你应该可以看到一个个性的问候。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;示例2-2 hello.py：带有动态路由的Flask应用程序&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@app.route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;/user/&amp;lt;name&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;h1&amp;gt;Hello, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;!&amp;lt;/h1&amp;gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议：如果你有克隆在GitHub上的应用程序的，你现在可以运行&lt;code&gt;git checkout 2b&lt;/code&gt;来切换到这个版本的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;测试动态路由，确保服务正在运行随后访问 &lt;em&gt;http://localhost:5000/user/young&lt;/em&gt; 。生成的应用程序会使用动态参数名响应一个定制的问候。尝试不同的名称，看看视图函数总是生成响应基于给定的名称。图像2-2展示的一个示例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/flask2-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;图像2-2 hello.py 动态路由&lt;/em&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Aug 2014 01:26:38 +0800</pubDate>
        <link>/flask/2014/08/19/flask-2-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/19/flask-2-1.html</guid>
      </item>
    
      <item>
        <title>Flask教程 —— 安装</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;1、安装虚拟环境&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;安装&lt;strong&gt;Flask&lt;/strong&gt;最方便的方法就是使用虚拟环境。虚拟环境是在Python解释器上的一个私有复制，你可以在一个隔绝的环境下安装packages，不会影响到你系统中全局的Python解释器。&lt;/p&gt;

&lt;p&gt;虚拟环境非常有用，因为它可以防止系统出现包管理混乱和版本冲突的问题。为每个应用程序创建一个虚拟环境可以确保应用程序只能访问它们自己使用的包，从而全局解释器只作为一个源且依然整洁干净，更多的虚拟环境可以被创建。另一个好处是，虚拟环境不需要管理员权限。&lt;/p&gt;

&lt;p&gt;虚拟环境由第三方程序&lt;strong&gt;virtualenv&lt;/strong&gt;创建。检查在你的系统中是否已经安装，可以输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你得到一个错误，你需要安装该程序。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：Python 3.3增加了本地支持的虚拟环境通过venv模块和pyvenv命令。pyenv可以用来代替virtualenv，但是注意通过pyvenv创建的虚拟环境不包含pip，需要手动安装。这个限制会在Python 3.4中移除，到时候pyvenv可以当作完整的virtualenv替代品。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大多数Linux发行版都提供一个virtualenv包。例如，Ubuntu用户就可以使用以下命令进行安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Mac OSX，你可以使用easy_install安装virtualenv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的是Microsoft Windows或者是任何没有提供官方virtualenv包的操作系统，接下来你会有一个稍微复杂的安装过程。&lt;/p&gt;

&lt;p&gt;使用你的web浏览器，导航到&lt;a href=&quot;https://bitbucket.org/pypa/setuptools&quot;&gt;https://bitbucket.org/pypa/setuptools&lt;/a&gt;，setuptools安装程序的主页，找到链接下载一个叫ez_setup.py安装程序脚本。保存这个文件到你电脑的临时文件夹中，然后在那个目录下运行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python ez_setup.py
$ easy_install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：前一个命令必须由管理员权限的账户发出。在Microsoft Windows，以管理员身份选项运行命令提示符窗口。在基于Unix的系统中，两个安装命令前面必须加上&lt;code&gt;sudo&lt;/code&gt;或作为&lt;code&gt;root&lt;/code&gt;用户执行。一旦安装完毕，virtualenv程序可以通过普通账户执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在你需要创建文件夹用来组织从GitHub仓库中获取的示例代码。在十三页中《如何使用示例代码》讨论的那样，最方便的方法就是使用Git客户端直接从Github中检出代码。下面的命令从GitHub中下载示例代码并初始化应用程序文件目录为“1a”版本，初始版本的应用程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/miguelgrinberg/flasky.git
$ cd flasky
$ git checkout 1a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步就是使用virtualenv命令创建Python虚拟环境到flasky文件夹中。这个命令有一个需要的参数：虚拟环境的名称。一个指定名称的文件夹和在里面的、与虚拟环境相关的所有文件会在当前目录下被创建。一般给虚拟环境约定命名为venv：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ virtualenv venv
New python executable in venv/bin/python2.7
Also creating executable in venv/bin/python
Installing setuptools............done.
Installing pip...............done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你有一个venv文件夹在flasky文件夹里面和一个全新的虚拟环境，包含一个私有的Python解释器。使用虚拟环境的时候，你必须“激活”它。如果你是使用bash命令行工具(Linux和Mac OSX用户)，你可以使用这个命令激活虚拟环境：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source venv/bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你是使用Microsoft Windows，激活命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ venv\Scripts\activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当虚拟环境被激活了，Python解释器的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中，但是这个改动并不是永久的；它只影响当前命令会话。提醒一下，你激活了虚拟环境，该激活命令会将环境的名称包含在命令提示符里面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在虚拟环境中完成工作并想回到全局Python解释器，在命令提示符中输入&lt;code&gt;deactivate&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h3 id=&quot;pippython&quot;&gt;&lt;strong&gt;2、使用pip安装python包&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;大多数的Python包是通过&lt;strong&gt;pip&lt;/strong&gt;程序安装的，在创建虚拟环境的时候virtualenv会自动添加进去。当一个虚拟环境被激活后，pip程序的位置会被添加到&lt;code&gt;PATH&lt;/code&gt;中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：如果你使用pyvenv创建虚拟环境在Python 3.3中，则必须手动安装pip。安装指令在pip网站上可以找到。在Python 3.4下，pyvenv会自动安装pip。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装Flask到虚拟环境中，使用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ pip install flask
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这个命令，Flask和它的依赖集都会安装到虚拟环境中。你可以验证Flask是否正确安装通过启动Python解释器并试着导入它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(venv)$ python
&amp;gt;&amp;gt;&amp;gt; import flask
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要安装的包比较多的时候，这样做会比较繁琐，我们还有一键安装的方法。首先新建一个文本文件，如：&lt;code&gt;requirements.txt&lt;/code&gt;，然后将你需要安装的包名保存到该文件中(根据自己的需要)，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Babel==1.3
Flask==0.10.1
Flask-Login==0.2.7
Flask-SQLAlchemy==1.0
Flask-WTF==0.9.3
Jinja2==2.7.1
SQLAlchemy==0.8.2
WTForms==1.0.5
Werkzeug==0.9.4
psycopg2==2.5.1
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你只需要输入以下命令，所有需要的包就可以全部安装好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有出现错误，祝贺你：你可以准备进入下一章节，接着你就可以写你的第一个web应用程序了。&lt;/p&gt;

</description>
        <pubDate>Sat, 16 Aug 2014 19:32:38 +0800</pubDate>
        <link>/flask/2014/08/16/flask-1-1.html</link>
        <guid isPermaLink="true">/flask/2014/08/16/flask-1-1.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet源码剖析1</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a style=&quot;border-bottom: 2px solid #ecf0f1;&quot; href=&quot;http://blog.segmentfault.com/young_ipython/1190000000626309&quot;&gt;greenlet篇&lt;/a&gt;中只是简单讲述了一下greenlet原理，不知道有没有人对源码感兴趣的，不过我还是比较感兴趣的。对于技术我一直都觉得『
知其然，知其所以然』才是最好的，不希望自己只停留在知道用，而不知道为什么这样用。&lt;/p&gt;

&lt;p&gt;一篇可能介绍不完，所以可能需要分几部分来介绍。当我写到这的时候突然发现自己是不是写跑题了，本来是写greenlet源码分析的，结果变成了怎么去写Python扩展了。不过不管怎样，就当多学习了一些其他知识，况且分析源码肯定少不了对这些知识的了解。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;模块初始化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;greenlet是用C编写的一个扩展模块，即用Python去调用C程序。像下面这段代码，内部都是怎样的一个过程呢？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gr2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gr1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gr1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gr2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gr1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码中，我们看到&lt;code&gt;from greenlet import greenlet&lt;/code&gt;这句，相信都能明白是导入了一个模块。为什么要导入这个模块呢？这个问题有点瞧不起大家了，因为我们可能需要使用这个模块的某个功能。那在导入这个模块的时候，Python解释器需要做哪些工作呢？在使用一个类的时候，我们肯定是需要调用构造函数来初始化的，导入模块就类似于这样的一个初始化过程。所以肯定会有一个初始化函数，它长啥样？&lt;/p&gt;

&lt;p&gt;在文档中有这样一句：The initialization function must be named &lt;code&gt;initname()&lt;/code&gt;, where &lt;em&gt;name&lt;/em&gt; is the name of the module, and should be the only non-static item defined in the module file.&lt;/p&gt;

&lt;p&gt;所以对于greenlet，我们就能找到&lt;code&gt;initgreenlet(void)&lt;/code&gt;函数。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define INITERROR return&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 第一次导入greenlet模块时调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PyMODINIT_FUNC&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initgreenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_api_object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_PyGreenlet_API&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyGreenlet_API_pointers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;GREENLET_NOINLINE_INIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py_InitModule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;greenlet&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GreenMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;INITERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先根据模块名查找相应的初始化函数，然后&lt;code&gt;Py_InitModule()&lt;/code&gt;函数向Python解释器注册该模块中所有可以用到的方法。而&lt;code&gt;Py_InitModule()&lt;/code&gt;函数是由Python提供的C API，对于使用C API只需要包含一个头文件就可以了。&lt;/p&gt;

&lt;p&gt;官方文档描述：All function, type and macro definitions needed to use the Python/C API are included in your code by the following line:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;quot;Python.h&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;方法列表&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;看下关键代码&lt;code&gt;m = Py_InitModule(&quot;greenlet&quot;, GreenMethods)&lt;/code&gt;。官方文档描述：Create a new module object based on a name and table of functions, returning the new module object.&lt;/p&gt;

&lt;p&gt;里面提到了table of functions，在这个模块中指的就是&lt;code&gt;GreenMethods&lt;/code&gt;，一般称它为方法列表。该列表给出了所有可以被Python解释器使用的方法，将这些方法注册到这个模块中，这样在我们导入模块后就可以直接使用了。&lt;/p&gt;

&lt;p&gt;当Python程序第一次导入greenlet模块的时候，调用&lt;code&gt;initgreenlet()&lt;/code&gt;函数。接着&lt;code&gt;Py_InitModule()&lt;/code&gt;会创建一个“模块对象”（它将被插入到&lt;code&gt;sys.modules&lt;/code&gt;字典下的“greenlet”键下），并且将方法列表（PyMethodDef结构数组）构成的内建函数对象作为它的第二个参数传到刚被创建的模块中。&lt;code&gt;Py_InitModule()&lt;/code&gt;返回一个指向它创建的模块对象的指针。方法列表代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyMethodDef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GreenMethods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;getcurrent&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyCFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod_getcurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;METH_NOARGS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*XXX*/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法列表中的各项参数如下：
&lt;img src=&quot;http://young-py.github.io/imgs/gevent3-01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(PyCFunction)mod_getcurrent&lt;/code&gt;函数如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mod_getcurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;STATE_OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Py_INCREF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ts_current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ts_current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该函数的作用就是获取当前greenlet对象，并添加引用计数。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;一个模块的初始化工作大致是这样的。不过针对greenlet发现了一些问题，在该模块的方法列表中看到了&lt;code&gt;getcurrent&lt;/code&gt;，而其他像&lt;code&gt;switch&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;等却没有看到。随后去查阅greenlet的官方文档，看到了&lt;code&gt;greenlet.getcurrent()&lt;/code&gt;和&lt;code&gt;g.switch(*args, **kwargs)&lt;/code&gt;，却被分别安排在『实例化』和『greenlets的方法和属性』两个不同的标题之下，为什么要这样区分呢？&lt;/p&gt;

&lt;p&gt;以上部分都是一个Python C扩展模块基本的初始化工作，针对greenlet还有其他要做的。具体怎么做以及上面问题的答案就放到下一篇讲吧，因为内容比较多在这篇讲不完。&lt;/p&gt;

</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent2.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent2.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— greenlet</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gevent文档：that uses greenlet to provide a high-level synchronous API.&lt;/p&gt;

&lt;p&gt;意思是：使用&lt;strong&gt;greenlet&lt;/strong&gt;来提供&lt;strong&gt;高级同步API&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那greenlet又是怎样一种机制呢？这个后面会稍微简单的讲一下原理，不过在后续的几篇会着重分析它的源码。在开始之前先看看提到的几个关键字『高级』、『同步』，高级不高级暂时还不知道，毕竟在实际生产环境中才看得到效果。而同步这个概念，不知道大家理解深不深刻，总之我当初理解不是很深刻，所以遇到了就聊聊呗！&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;不明白为什么会叫同步，总是让我有一种错觉，让我联想到的第一个词汇就是同时进行。不知道大家是不是和我一样，至少我看到同步是不会去想到它的正确意思。我曾一度怀疑是不是翻译错了，但是在质疑别人错之前，应该先质疑一下自己。所以我开始怀疑我的语文没学好，然后我去查了一下汉语词典，结果就悲剧了，我已经开始怀疑我的人生了。 %&amp;gt;_&amp;lt;%&lt;/p&gt;

&lt;p&gt;同步：指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;《光明日报》1984.6.2：“城市改革的步子要加快，要从解决国家与企业、企业与职工的关系入手，把适合于当前情况的各项改革措施初步配起套来，同步进行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从上面引用的话应该可以看出，国家与企业、企业与职工，都是两个相对的关系，有着各自的利益。但是他们必须合作才能完成一个共同目标，例如买票看电影。这个场景有两个动作需要完成，一个出票、一个买票，只有出票才能买票，并且这个买票的人还只能傻等，不能做其他事。&lt;/p&gt;

&lt;p&gt;同步真心不是同时进行，所以还是要多读书啊！尤其是语文！&lt;/p&gt;

&lt;p&gt;为什么这里会讲到同步呢？其实不讲也是可以的，和理解greenlet原理没有多大关系，但是和理解gevent的特性有那么点关系，因为听别人说gevent能够让你用这种同步的代码写出异步的感觉，同步的代码好理解也好处理。我没有验证过，所以我也不知道，真正的原因是感觉这个概念很容易混淆，所以就来讲讲了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;greenlet&quot;&gt;&lt;strong&gt;Greenlet&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;还记得在&lt;a style=&quot;border-bottom: 2px solid #ecf0f1;&quot; href=&quot;http://blog.segmentfault.com/young_ipython/1190000000534263&quot;&gt;协程篇&lt;/a&gt;中学习的吗？花了较长篇幅讲协程及从其子例程演变的过程。而greenlet就是python中实现Coroutine「协程」的一个基础库。前面我们了解了协程的相关概念及思想，但我们还不知道它在底层是怎样实现的。只知道它有个特别的地方，就是能够和进程、线程一样保存上下文，那协程的上下文是怎样保存的呢？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;源码初探&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject_HEAD&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;intptr_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_saved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_greenlet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;top_frame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recursion_depth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weakreflist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PyObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PyGreenlet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面给出的是greenlet的结构体定义，有兴趣的可以去下一份源代码看看，里面也有很好的解释。&lt;/p&gt;

&lt;p&gt;这里我们主要了解一下关于堆栈的几个操作，从命名规则就可以找到我们想要的东西，就是它们几个了：&lt;code&gt;stack_start&lt;/code&gt;、&lt;code&gt;stack_stop&lt;/code&gt;、&lt;code&gt;stack_copy&lt;/code&gt;、&lt;code&gt;stack_saved&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其实仔细想想，你会发现非常的简单。假设有『函数A』和『函数B』，『函数A』进栈执行到一半的时候需要调用『函数B』，没事这个简单，我们可以将『函数B』进栈(图stack-01)。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:130px; height:190px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-03.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好了『函数B』进栈了，可它现在又想调用『函数A』了，怎么办？让『函数A』进栈(图stack-02)，这个其实就是普通的函数调用，此『函数A』并不是第一次进栈的那个『函数A』，而是重新在栈中创建的一个实例，该实例的数据并不是之前『函数A』的数据，可是我想要之前『函数A』的数据啊！所以这个方法并不能实现我们想要的切换。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:130px; height:245px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-04.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那怎样才能做到我们想要的呢？很简单，既然『函数B』完成了当前的任务，它就应该退出来了，但并不是直接出栈，而是通过某种方式将现有的state给记录下来，方便下次用到的时候能够找到。怎么记录呢？这里就可以回到上面我们需要了解的几个栈操作了。&lt;/p&gt;

&lt;p&gt;首先，每个greenlet都有属于它们自己的&lt;code&gt;stack_start&lt;/code&gt;和&lt;code&gt;stack_stop&lt;/code&gt;，通过这两个可以找到你准备出栈的greenlet也就是『函数B』的所有数据，之后再调用&lt;code&gt;PyMem_Realloc&lt;/code&gt;这个方法，就可以在heap中创建一个内存空间用来存放『函数B』，地址为stack_copy，大小为stack_saved字节，通过这两个就可以定位到你存放的『函数B』的数据了(图stack-03)。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:575px; height:205px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-05.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后变成下面(图stack-04)这样了。这个时候，如果『函数A』执行完了想去执行『函数B』的时候，就按照这个流程再保存，然后再把刚才存放的『函数B』给复制到C栈中。因为已经知道了&lt;code&gt;stack_copy&lt;/code&gt;和&lt;code&gt;stack_saved&lt;/code&gt;，所以也就不怕找不到它了。&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:250px; height:140px;&quot; src=&quot;http://young-py.github.io/imgs/gevent2-06.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个greenlet切换流程大概就是这个样子了，不过到了这里不知道大家会不会有些疑问，虽然保存了&lt;code&gt;stack_copy&lt;/code&gt;和&lt;code&gt;stack_saved&lt;/code&gt;，但是『函数B』已经出栈了，不是就没有这个对象了吗？那这两个参数是由谁来保存呢？&lt;/p&gt;

&lt;p&gt;其实这个对象从来就没有被销毁，只要这个greenlet没有正常退出，它的对象就一直都存在着，因为Greenlet还维护着一个链表，它保存着所有没有彻底退出的greenlet对象，『函数B』出栈并不是完全退出了，只是不参与这次行动。具体的细节就要等到下一篇或者下下篇的源码剖析来讲解了。&lt;/p&gt;

&lt;p&gt;因为最近工作比较忙，换了一个部门，加上之前对源码理解不够，也就不敢随便发表。当然现在发表的也不敢说绝对正确，这些仅仅是我个人的理解，欢迎大神来指正。&lt;/p&gt;

</description>
        <pubDate>Sun, 29 Jun 2014 00:48:45 +0800</pubDate>
        <link>/gevent/2014/06/29/gevent1.html</link>
        <guid isPermaLink="true">/gevent/2014/06/29/gevent1.html</guid>
      </item>
    
      <item>
        <title>gevent 学习笔记 —— 协程</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://young-py.github.io/imgs/yyzt.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在学习gevent之前，你肯定要知道你学的这个东西是什么。&lt;/p&gt;

&lt;h3 id=&quot;gevent&quot;&gt;&lt;strong&gt;官方描述gevent&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.&lt;/p&gt;

&lt;p&gt;翻译：gevent是一个基于协程的Python网络库。我们先理解这句，也是这次学习的重点——&lt;strong&gt;协程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;wiki&quot;&gt;&lt;strong&gt;wiki描述协程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;与子例程一样，协程也是一种程序组件&lt;/strong&gt;。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。子例程的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次；协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。协程允许多个入口点，可以在指定位置挂起和恢复执行。&lt;/p&gt;

&lt;p&gt;没看懂？没关系，我也没看懂，不过算是有点线索：&lt;strong&gt;子例程&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;子例程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;过程有两种，一种叫子例程（Subroutine），通常叫Sub；另一种叫函数（Function）。底层实现机制是一样的，区别在于，Sub只执行操作，没有返回值；Function不但执行操作，并且有返回值。用过VB的应该会比较清楚这点。（原谅我用了百度百科）说到底子例程就是过程，我们一般叫它函数。&lt;/p&gt;

&lt;p&gt;说到函数，我就想吐槽了，不明白为什么要叫函数。很多时候我们写一个函数是为了封装、模块化某个功能，它是一个功能、或者说是一个过程。因为它包含的是类似于流程图那样的具体逻辑，先怎样做，然后怎样做；如果遇到A情况则怎样，如果遇到B情况又怎样。叫做函数就让人很纠结了，难道因为回归到底层还是计算问题，出于数学的角度把它称为函数？这个略坑啊！为了符合大家的口味，我还是称之为函数好了（其实我也习惯叫函数了%&amp;gt;_&amp;lt;%）。&lt;/p&gt;

&lt;p&gt;讲到子例程，我们就往底层挖掘一下，看看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;a start&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;a end&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;b start&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;b end&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;c start&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;c end&amp;quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于这样的结果大家肯定不会意外的。每当函数被调用，就会在栈中开辟一个栈空间，调用结束后再回收该空间。&lt;/p&gt;

&lt;p&gt;假设一个这样的场景：有个讲台，每个人都可以上去发表言论，但是每次讲台只能站一个人。现在a在上面演讲，当他说到“大家好！”的时候，b有个紧急通知要告诉大家，所以a就先下来让b讲完通知，然后a再上讲台继续演讲。如果用函数的思想解决，堆栈示意图是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;width:461px; height:172px;&quot; src=&quot;http://young-py.github.io/imgs/gevent0-01.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家会不会发现问题，就是每次a继续演讲都要重新开始。因为函数在重新调用的时候，它的局部变量是会被重置的，对于之前他说的那句“大家好”，他是不会记得的（可能a的记性不好）。那有没有什么办法可以不让他重复，而是在打断之后继续呢？很简单，在他走下讲台之前记住当前说过的话。表现在函数中就是在退出之前，保存该函数的局部变量，方便在重新进入该函数的时候，能够从之前的局部变量开始继续执行。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;升级版&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果你有一段代码生产数据，另外一段代码消费数据，哪个应该是调用者，哪个应该是被调用者？&lt;/p&gt;

&lt;p&gt;例如：生产者 —— 消费者问题，先抛开进程、线程等实现方法。假设有两个函数producer和consumer，当缓冲区满了，producer调用consumer，当缓冲区空了，consumer调用producer，但是这样的函数互相调用会出什么问题？&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;生产一个&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;消费一个&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;producer调用consumer，producer并没有退出，这个时候consumer又继续调用producer，consumer也没有退出。这样无限次数的调用，都会在栈中开辟空间，很快就会因为栈空间不足造成堆栈溢出错误。其实函数并不具备解决这类问题的能力，函数每次退出都会清空该实例的栈帧，每次进入都是重新开始，函数不具备保存退出点和局部状态的能力。&lt;/p&gt;

&lt;p&gt;那什么东西有这样的能力呢？我们很快就可以想到进程、线程，但是你真的想使用进程、线程如此重量级的东西在这么简单的程序上吗？野蛮的抢占式机制和笨重的上下文切换！&lt;/p&gt;

&lt;p&gt;还有一种程序组件，那就是协程。它能保留上一次调用时的状态，每次重新进入该过程的时候，就相当于回到上一次离开时所处逻辑流的位置。协程的起始处是第一个入口点，&lt;strong&gt;在协程里，返回点之后是接下来的入口点&lt;/strong&gt;。协程的生命期完全由他们的使用的需要决定。每个协程在用yield命令向另一个协程交出控制时都尽可能做了更多的工作，放弃控制使得另一个协程从这个协程停止的地方开始，接下来的每次协程被调用时，都是从协程返回（或yield）的位置接着执行。&lt;/p&gt;

&lt;p&gt;从上面这些你就可以知道其实协程是模拟了多线程（或多进程）的操作，多线程在切换的时候都会有一个上下文切换，在退出的时候将现场保存起来，等到下一次进入的时候从保存的现场开始，继续执行。&lt;/p&gt;

&lt;p&gt;看下协程是怎样实现的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;greenlet&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greenlet&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Produced: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@greenlet&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Consumed: &amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;协程其实模拟了人类活动的一种过程。例如：你准备先写文档，然后修复bug。这时候接到电话说这个bug很严重，必须立即修复（可以看作CPU通知）。于是你暂停写文档，开始去填坑，终于你把坑填完了，你回来写文档，这个时候你肯定是接着之前写的文档继续，难道你要把之前写的给删了，重新写？这就是协程。那如果是子例程呢？那你就必须重新写了，因为退出之后，栈帧就会被弹出销毁，再次调用就是开辟新的栈空间了。&lt;/p&gt;

&lt;p&gt;总结：协程就是用户态下的线程，是人们在有了进程、线程之后仍觉得效率不够，而追求的又一种高并发解决方案。为什么说是用户态，是因为操作系统并不知道它的存在，它是由程序员自己控制、互相协作的让出控制权而不是像进程、线程那样由操作系统调度决定是否让出控制权。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 May 2014 21:34:03 +0800</pubDate>
        <link>/gevent/2014/05/08/gevent0.html</link>
        <guid isPermaLink="true">/gevent/2014/05/08/gevent0.html</guid>
      </item>
    
  </channel>
</rss>
