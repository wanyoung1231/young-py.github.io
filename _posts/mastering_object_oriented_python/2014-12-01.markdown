---
layout: post
title:  "面向对象的Python —— __init__()方法"
date:   2014-12-01 21:52:40
categories: mastering_object_oriented_python
author: young
---

`__init__()`方法深奥有两个原因。初始化是对象的生命周期最重要的一步；每个对象必须正确初始化后才能正常工作。第二个原因是`__init()__`参数值可以多种形式。

因为有很多种方式为`__init__()`提供参数值，有大量的用例用于对象创建。我们可以看看其中的几个。我们想尽可能的弄清楚，因此我们需要定义一个初始化来正确的表示问题区域。

在我们接触`__init__()`方法之前，无论如何，我们都需要粗略、简单地看看在Python中隐含的`object`类的层次结构。

在这一章，我们看看不同形式的简单对象的初始化（例如，打牌）。在这之后，我们可以看看更复杂的对象，就像手潜心于收集和玩家潜心于策略和状态。

### **隐含的超类——object**

每一个Python类都隐含了一个超类：**object**。它是一个非常简单的类定义，几乎不做任何事情。我们可以创建`object`的实例，但是我们不能用它做太多，因为许多特殊的方法容易抛出异常。

当我们定义一个自己的类，`object`则为超类。下面是一个类定义示例，它使用新的名称简单的继承了`object`：

    class X:
        pass

下面是和我们的类的一些交互：

    >>> X.__class__
    <class 'type'>
    >>> X.__class__.__base__
    <class 'object'>

我们可以看到类是`type`类的一个对象，且我们新类的基类为`object`。

我们看看每个方法，我们也看看从`object`继承的默认行。在某些情况下，超类特殊方法行为将是我们所想要的。在其他情况下，我们需要覆盖这个特殊方法。

### **基类对象的__init__()方法**

对象生命周期的基础是创建、初始化和销毁。我们将创建和销毁的更高级的特殊方法推迟到后面的章节，目前只关注初始化。

所有类的超类、`object`，有一个`__init__()`默认实现。我们不需要去实现`__init__()`。如果我们不实现它，则在对象创建后就不会创建实例变量。在某些情况下，这个默认行为是可以接受的。

我们通常增加给对象添加属性











