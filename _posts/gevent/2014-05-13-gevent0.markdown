---
layout: post
title:  "gevent 学习笔记 —— 协程"
date:   2014-05-08 13:34:03
categories: gevent
author: young
---

![](http://0.0.0.0:4000/imgs/yyzt.jpeg)

在学习gevent之前，你肯定要知道你学的这个东西是什么。

### **官方是这样描述gevent的**
 
gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.

翻译：gevent是一个基于协程的Python网络库。我们先理解这句，也就是我想学习的重点——**协程**。

-----

### **wiki是这样描述协程的**

与子例程一样，协程也是一种程序组件。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。子例程的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次；协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。

是不是让人很捉急？我想是的！看完之后我仍不知道协程是什么，能干什么，莫名其妙的抛出个子例程就表示大家能看懂？查阅很多资料后，我给出的解释：协程就是人们在有了进程、线程之后仍觉得效率不够，而追求的另一种高并发解决方案。

是不是还不明白？没关系，至少有了大致的方向，是解决高并发实现多任务，所以我们可以尽量往这个方向去想。

-----

在这之前我们先讲讲函数，函数是描述每个输入值对应唯一输出值的一种对应关系。

如果让大家实现这样一个功能，写两个函数ping和pong，各执行5次。我想到的是下面这样的代码：

{% highlight python %}

def main():
   
    for i in range(5):
        ping(i+1)
        pong(i+1)

def ping(i):
   
    print "ping: %s" % i

def pong(i):
   
    print "pong: %s" % i

if __name__ == "__main__":
    main()

{% endhighlight %}

有个新的要求：
如果我现在想要在执行ping函数的时候中断，去执行pong函数；执行pong函数的时候中断，去执行ping函数呢？我用的是下面的代码：

{% highlight python %}

def ping(i):
   
    print "ping start: %s" % i

    pong(i+1)
   
    print "ping end: %s" % i

def pong(i):
   
    print "pong start: %s" % i
    if i == 10:
        return
    ping(i+1)
   
    print "pong end: %s" % i

if __name__ == "__main__":
    ping(1)

{% endhighlight %}

输出结果是这样的:

    ping start: 1
    pong start: 2
    ping start: 3
    pong start: 4
    ping start: 5
    pong start: 6
    ping start: 7
    pong start: 8
    ping start: 9
    pong start: 10
    ping end: 9
    pong end: 8
    ping end: 7
    pong end: 6
    ping end: 5
    pong end: 4
    ping end: 3
    pong end: 2
    ping end: 1

不知道大家觉得这个结果会不会很意外？为什么会输出这么多的end？其实也没啥意外的，如果了解函数调用的底层机制就应该会明白的。在底层都是用栈来存放函数的参数，所以每次调用一个函数都是将该函数压入栈中，当函数返回的时候又会将函数从栈中弹出，所以当最后一次调用pong函数的时候函数返回到pong函数的调用者ping函数，然后输出end，该ping函数又调用它的调用者pong函数，如此就形成了后面的那些end。

从上面这些分析，大家觉得这是交替执行吗？其实不是的，因为每次从ping函数中断跳到pong函数或者相反，都是重新在栈空间中开辟了新的栈空间（叫栈帧），虽然5次调用了ping函数和pong函数，每次函数的参数和局部变量都重新初始化了，每次操作的都不是同一个局部变量。况且这才是互相调用了5次，如果是无限次数的调用话，很快栈空间就会被消耗掉，导致栈溢出。

那怎样才能做到我们想要的交替执行呢？


如果我想要实现这样一种功能：
有两个任务需要完成，分别用ping函数和pong函数代替。每个任务都是完成一个变量i自增的功能，只不过每次只有一个任务自增，自增完一次后就换另一个任务自增，总共自增5次。意思就是首先让ping函数自增，自增完后交给pong函数自增。 

想用普通的函数去完成是不可能的。因为每次任务的切换普通的函数都会在栈中生成新的栈帧。新的栈帧就是新初始化的函数内部变量，如果ping函数执行+1，切换到pong函数执行+1，再切换回来的时候其实是重新初始化局部变量，ping函数还是输出1。

而协程就提供这样一种功能，当你重新进入ping函数的时候，ping函数的局部变量还保留上一次退出该函数时的局部变量，并从上次中断的地方开始执行。

从上面这些你就可以知道其实协程是模拟了多线程的操作，多线程在切换的时候都会有一个上下文切换，在退出的时候将现场保存起来，等到下一次进入的时候从保存的现场开始，继续执行。

看下协程是怎样实现的：

{% highlight python %}

from time import sleep
from greenlet import greenlet

@greenlet
def ping():

    i = 0

    for i in range(5):
        i += 1
        print "ping %s" % i
        sleep(1)
        pong.switch()

@greenlet
def pong():

    i = 0

    for i in range(5):
        i += 1
        print "pong %s" % i
        sleep(1)
        ping.switch()

if __name__ == "__main__":
    ping.switch()

{% endhighlight %}

### **总结**
协程其实模拟了人类活动的一种过程。例如：你准备写文档，然后修复bug。这时候接到电话说这个bug很严重，必须立即修复（可以看作CPU通知）。于是你暂停写文档，开始去填坑，终于你把坑填完了。你回来写文档，这个时候你肯定是接着之前写的文档继续，难道你要把之前写的给删了，重新写？这就是协程。

那如果是函数呢？那你就必须重新写了，因为退出函数以后，栈帧就会被弹出销毁，再次调用就是开辟新的栈空间了。

协程就是拥有这种能力的东西。它可以让你从一个函数反映了程序逻辑的一种需求：可重入能力。这个能力很重要，因为大多数语言的一个最重要的组件--函数，其实就依赖这个能力的弱化版本。函数中的局部变量，被你初始化为特定的值，每次你调函数，换种说法:重入函数，语言都保证这些局部变量的值不会改变。相同的输入，得到相同的输出。当然你跟我扯全局变量就没意思了。

语言实现到函数这一步，可以满足绝大多数日常需求了。但工程师就是又懒又爱折腾啊。函数在很多语言特别是早期语言中，有个别名：过程（具体特性不一定相同，就不追究了，整体的行为还是差不离的）。我觉得过程这个词比函数更贴切。现在我们把“函数中局部变量的值”换种说法，叫做“过程中的局部状态”，这个说法更广泛了。每次重入过程，过程中的局部状态都被重置。要想得到不同的输出状态，唯有改变输入的状态。要想明确一个输出状态，对应的输入状态，唯有记录下输入状态。so simple，so native。问题是那帮懒惰的工程师甚至连输入状态都不想保存判断啊。他们希望有这么一种过程，每次进入，过程里的局部状态，都能保留上一次进入的状态。自然也就不需要干针对输入状态的保存或判断工作了。换言之，这个特殊过程把原来需要在过程之外的用来控制过程输出状态的那些输入状态的管理工作，都交给过程本身了。

这个特殊的过程，就叫做协程。它能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。普通过程（函数）可看成这个特殊过程的一个特例：只有一个状态，每次进入时局部状态重置。这种逻辑控制上的方便当然让这帮懒惰的工程师乐翻了天，少打了好多字，可以向老板叫嚣生产力提高了，其实又可以多lol几把了，对不对？用协程的好处是，你处在更高的逻辑层面去审视需求，整理代码。没有函数之前，你只有表达式，没有表达式之前，你只有mov。没有if-else之前，你只有jump。脱离低级的逻辑处理，就意味着能在更高的抽象层面看问题。就好像如果你在算傅里叶变换时，还要每次去思考四则混合运算规则，只能是自作死。协程之所以陌生，是因为这个能力很强大，因此通常跟实际业务联系很紧密吧。



