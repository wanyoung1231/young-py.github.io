---
layout: post
title:  "gevent 学习笔记 —— 协程"
date:   2014-05-08 13:34:03
categories: gevent
author: young
---

![](http://young-py.github.io/imgs/yyzt.jpeg)

在学习gevent之前，你肯定要知道你学的这个东西是什么。

### **官方描述gevent**
 
gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.

翻译：gevent是一个基于协程的Python网络库。我们先理解这句，也是这次学习的重点——**协程**。

-----

### **wiki描述协程**

**与子例程一样，协程也是一种程序组件**。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。子例程的起始处是惟一的入口点，一旦退出即完成了子例程的执行，子例程的一个实例只会返回一次；协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。

没看懂？没关系，我也没看懂，不过算是有点线索：**子例程**。

-----

### **子例程**

过程有两种，一种叫子例程 (Subroutine)，我们通常叫做 Sub；另外一种叫函数，通常叫 Function。两者区别在于，Sub 只执行操作，没有返回值；Function 不但执行操作，并且有返回值。请原谅我用百度百科。

{% highlight python %}

def a():
    print "call a"
    b()

def b():
    print "call b"

{% endhighlight %}

函数b是函数a的子例程，它们之间有严格的从属关系，函数a调用函数b，函数a是调用者，函数b是被调用者。如果这个时候函数b又调用函数a，也就是说函数a是函数b的子例程，这样做是否可行？

{% highlight python %}

def a():
    print "call a"
    b()

def b():
    print "call b"
    a()

{% endhighlight %}

理论上是不可行的，它们之间有着严格的从属关系，通俗点讲b是a的儿子，a却不能是b的儿子。但是，实际情况，如果函数堆栈无限大的情况下是可以的，子例程是可以多次被调用的，因为每次调用都是在函数栈中创建新的空间，虽然实现的功能是一致的，但因为是在不同的内存空间中，所以本质上不是同一个东西。所以a调用b，b又调用a是可以的，只是此a不是子例程a，而是子例程a众多实例中的一个。不过函数堆栈无限大只是个如果，所以实际上也是不可行的。否则就会因为无限的在函数堆栈上创建新的空间，导致栈空间不足造成堆栈溢出错误。上面的代码应该是一眼就可以看出错误来的，只是这里细说了一下为什么不行。

为什么要实现互相调用呢？

子例程的一个实例

协程的一个实例

子例程 - 函数 - 函数底层机制

协程 彼此对称、平等 没有调用与被调用的关系 - 相互协作 - 协程底层机制

根据协程机制分析 怎么模拟线程 为什么高效

在这之前我们先讲讲函数，函数是描述每个输入值对应唯一输出值的一种对应关系。

如果让大家实现这样一个功能，写两个函数ping和pong，各执行5次。我想到的是下面这样的代码：

{% highlight python %}

def main():
   
    for i in range(5):
        ping(i+1)
        pong(i+1)

def ping(i):
   
    print "ping: %s" % i

def pong(i):
   
    print "pong: %s" % i

if __name__ == "__main__":
    main()

{% endhighlight %}

有个新的要求：
如果我现在想要在执行ping函数的时候中断，去执行pong函数；执行pong函数的时候中断，去执行ping函数呢？我用的是下面的代码：

{% highlight python %}

def ping(i):
   
    print "ping start: %s" % i

    pong(i+1)
   
    print "ping end: %s" % i

def pong(i):
   
    print "pong start: %s" % i
    if i == 10:
        return
    ping(i+1)
   
    print "pong end: %s" % i

if __name__ == "__main__":
    ping(1)

{% endhighlight %}

输出结果是这样的:

    ping start: 1
    pong start: 2
    ping start: 3
    pong start: 4
    ping start: 5
    pong start: 6
    ping start: 7
    pong start: 8
    ping start: 9
    pong start: 10
    ping end: 9
    pong end: 8
    ping end: 7
    pong end: 6
    ping end: 5
    pong end: 4
    ping end: 3
    pong end: 2
    ping end: 1

不知道大家觉得这个结果会不会很意外？为什么会输出这么多的end？其实也没啥意外的，如果了解函数调用的底层机制就应该会明白的。在底层都是用栈来存放函数的参数，所以每次调用一个函数都是将该函数压入栈中，当函数返回的时候又会将函数从栈中弹出，所以当最后一次调用pong函数的时候函数返回到pong函数的调用者ping函数，然后输出end，该ping函数又调用它的调用者pong函数，如此就形成了后面的那些end。

从上面这些分析，大家觉得这是交替执行吗？其实不是的，因为每次从ping函数中断跳到pong函数或者相反，都是重新在栈空间中开辟了新的栈空间（叫栈帧），虽然5次调用了ping函数和pong函数，每次函数的参数和局部变量都重新初始化了，每次操作的都不是同一个局部变量。况且这才是互相调用了5次，如果是无限次数的调用话，很快栈空间就会被消耗掉，导致栈溢出。

那怎样才能做到我们想要的交替执行呢？


如果我想要实现这样一种功能：
有两个任务需要完成，分别用ping函数和pong函数代替。每个任务都是完成一个变量i自增的功能，只不过每次只有一个任务自增，自增完一次后就换另一个任务自增，总共自增5次。意思就是首先让ping函数自增，自增完后交给pong函数自增。 

想用普通的函数去完成是不可能的。因为每次任务的切换普通的函数都会在栈中生成新的栈帧。新的栈帧就是新初始化的函数内部变量，如果ping函数执行+1，切换到pong函数执行+1，再切换回来的时候其实是重新初始化局部变量，ping函数还是输出1。

而协程就提供这样一种功能，当你重新进入ping函数的时候，ping函数的局部变量还保留上一次退出该函数时的局部变量，并从上次中断的地方开始执行。

从上面这些你就可以知道其实协程是模拟了多线程的操作，多线程在切换的时候都会有一个上下文切换，在退出的时候将现场保存起来，等到下一次进入的时候从保存的现场开始，继续执行。

看下协程是怎样实现的：

{% highlight python %}

from time import sleep
from greenlet import greenlet

@greenlet
def ping():

    i = 0

    for i in range(5):
        i += 1
        print "ping %s" % i
        sleep(1)
        pong.switch()

@greenlet
def pong():

    i = 0

    for i in range(5):
        i += 1
        print "pong %s" % i
        sleep(1)
        ping.switch()

if __name__ == "__main__":
    ping.switch()

{% endhighlight %}

### **总结**
协程其实模拟了人类活动的一种过程。例如：你准备写文档，然后修复bug。这时候接到电话说这个bug很严重，必须立即修复（可以看作CPU通知）。于是你暂停写文档，开始去填坑，终于你把坑填完了。你回来写文档，这个时候你肯定是接着之前写的文档继续，难道你要把之前写的给删了，重新写？这就是协程。

那如果是函数呢？那你就必须重新写了，因为退出函数以后，栈帧就会被弹出销毁，再次调用就是开辟新的栈空间了。

总结出：协程就是用户态下的线程，是人们在有了进程、线程之后仍觉得效率不够，而追求的又一种高并发解决方案。



