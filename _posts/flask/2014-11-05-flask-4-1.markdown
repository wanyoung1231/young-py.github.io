---
layout: post
title:  "Flask教程 —— Web表单（上）"
date:   2014-11-05 23:00:10
categories: flask
author: young
---

在第二章介绍的`request`对象，公开了所有由客户端发送的请求信息。特别地，`request.form`可以访问POST请求提交的表单数据。

尽管Flask的`request`对象提供的支持足以处理web表单，但依然有许多任务会变得单调、重复。两个很好的例子就是表单的HTML代码的生成和验证所提交的表单数据。

**Flask-WTF**扩展使处理web表单获得更愉快的体验。这个扩展是一个Flask集成，包装与框架无关的WTForms包。

Flask-WTF和它的依赖集可以通过pip来安装：

    (venv) $ pip install flask-wtf

### 1、跨站请求伪造(CSRF)保护

默认情况下，Flask-WTF保护各种形式对跨站请求伪造(CSRF)攻击。CSRF攻击发生在一个恶意网站发送请求到受害者登录的不同网站时。

为了实现CSRF保护，Flask-WTF需要应用程序去配置一个加密密钥。Flask-WTF使用这个密钥去生成加密令牌用于验证请求表单数据的真实性。示例4-1展示如何配置加密密钥。

_示例4-1. hello.py：Flask-WTF配置_

{% highlight python %}

app = Flask(__name__)
app.config['SECRET_KEY'] = 'hard to guess string'

{% endhighlight %}

`app.config`字典通常是框架、扩展或应用程序自身存放配置变量的地方，可以使用标准字典语法添加配置值到`app.config`中。配置对象还有方法来从文件或环境导入配置值。

`SECRET_KEY`配置变量作为Flask和一些第三方扩展的通用加密密钥。加密的强度取决于这个变量的值。给你构建的每个应用程序选择不同的密钥，并确保这个字符串不被其他任何人知道。

>注：为了提高安全性，密钥应该存储在一个环境变量中，而不是嵌入到代码中。这种个会在第7章中描述。

### 2、表单类

使用Flask-WTF时，每个web表单是由继承自`Form`类的子类来表现的。该类在表单中定义了一组字段，每个都表示为一个对象。每个字段都可以连接一个或多个**validators**；`validators`是一个用于检查用户提交的输入是否合法的函数。

示例4-2展示了一个拥有文本字段和提交按钮的简单web表单。

_示例4-2. hello.py：表单类定义_

{% highlight python %}

from flask.ext.wtf import Form
from wtforms import StringField, SubmitField 
from wtforms.validators import Required

class NameForm(Form):
    name = StringField('What is your name?', validators=[Required()]) submit = SubmitField('Submit')

{% endhighlight %}

表单中的字段被定义为类的变量，且每个类的变量都指定一个字段类型对象。在上一个示例中，`NameForm`表单有一个`name`文本字段和`submit`提交按钮。`StringField`类表示一个`type="text"`属性的`<input>`标签。`SubmitField`类表示一个`type="submit"`属性的`<input>`标签。字段构造函数的第一个参数是一个`label`，用于渲染表单到HTML。

`StringField`构造函数包含可选参数`validators`，它定义了一组检查来验证用户提交的数据。`Required()`验证确保提交的字段不为空。

>注：Flask-WTF扩展定义了表单基类，所以它从flask.ext.wtf导入。字段、验证都是直接从WTForms包中导入。

表格4-1展示了一组WTForms支持的标准字段。

_表格4-1. WTForms标准HTML字段_

表格4-2展示了一组WTForms内建验证。

_表格4-2. WTForms验证_

### 3、HTML渲染的表单

表单字段是可调用的，调用时从模板渲染它们到HTML。假设视图函数传递一个参数名为`form`的`NameForm`实例给模板，模板就会生成一个简单的HTML表单，如下所示：
    
{% highlight html %}

<form method="POST">
    { { form.name.label }} { { form.name() }} 
    { { form.submit() }}
</form>

{% endhighlight %}

当然，结果是什么都没有。为了改变表单的外观显示，任何发送给字段的参数会被转换为HTML字段属性；例如，你可以给定字段`id`或`class`属性，然后定义CSS样式：

{% highlight html %}

<form method="POST">
    { { form.name.label }} { { form.name(id='my-text-field') }} 
    { { form.submit() }}
</form>

{% endhighlight %}

尽管带有HTML属性，用这种方式渲染表单是效果是显著的，所以最后是尽可能的使用Bootstrap自带的一系列表单样式。Flask-Bootstrap使用Bootstrap的预定义表单样式来提供高级的帮助函数来渲染染整个Flask-WTF表单，这些操作都只需要一个调用即可完成。使用Flask-Bootstrap，上一个表单可以像下面这样来渲染：

{% highlight html %}

    { % import "bootstrap/wtf.html" as wtf %}
    { { wtf.quick_form(form) }}

{% endhighlight %}

`import`指令和常规的Python脚本一样的作用并且允许模板元素被导入并在许多模板中使用。被导入的`bootstrap/wtf.html`文件定义帮助函数使用Bootstrap渲染Flask-WTF表单。`wtf.quick_form()`函数携带Flask-WTF表单对象并使用默认Bootstrap样式渲染它。示例4-3展示了完整的`hello.py`模板。

_示例4-3. templates/index.html：使用Flask-WTF和Flask-Bootstrap渲染表单_

{% highlight html %}

{ % extends "base.html" %}
{ % import "bootstrap/wtf.html" as wtf %}
{ % block title %}Flasky{% endblock %}
{ % block page_content %}
<div class="page-header">
    <h1>Hello, { % if name %}{ { name }}{ % else %}Stranger{ % endif %}!</h1>
</div>
{ { wtf.quick_form(form) }}
{ % endblock %}

{% endhighlight %}

模板的内容区有两节。第一节是页头部展示一个问候。这里使用了模板条件



























