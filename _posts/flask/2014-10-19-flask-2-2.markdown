---
layout: post
title:  "Flask教程 —— 基本应用程序结构（下）"
date:   2014-10-19 17:31:30
categories: flask
author: young
---

### **5、请求-响应循环**

既然你已经玩过一个基本的Flask应用程序，你也许想要知道更多神奇的Flask是如何工作的。下面章节描述了一些这个框架的设计观点。

#### **5.1、应用程序和请求上下文**

当Flask从客户端收到一个请求，需要提供几个视图函数对象处理它。最好的例子就是 _请求对象_ ，它封装了客户端发送的HTTP请求。

Flask可以给视图函数进入请求对象最显然的方式就是作为一个参数发送它，但是这需要在应用程序中得每一个视图函数都有一个额外的参数。事情会变得更加复杂如果你考虑请求的对象不是唯一需要的对象。

为了避免弄乱视图函数那些可能需要或不可能需要的参数，Flask使用 _上下文_ 去临时确定可访问的全局对象。多亏有上下文，视图函数可以写成像下面这样：

{% highlight python %}

from flask import request

@app.route('/')
def index():
    user_agent = request.headers.get('User-Agent')
    return '<p>Your browser is %s</p>' % user_agent

{% endhighlight %}

注意这个视图函数请求是怎样被用作为一个全局变量。现实中，请求不能作为一个全局变量，如果你考虑在多线程的服务中，同一时间内线程工作在来自不同客户端的不同请求，所以没一个线程需要看到请求中的不同对象。上下文可以使得Flask确定变量全局性访问而不干扰其他线程。

>注：线程是可以独立管理的最小指令序列。一个进程中有多个活动的线程是非常常见的，有时分享内存或文件句柄资源。多线程web服务器会启动一个线程池并从池中选择一个线程来处理每个传入的请求。

Flask有两类上下文： _应用程序上下文_ 和 _请求上下文_ 。表2-1展示了这些上下文提供的变量。

_表2-1. Flask全局上下文_

Flask激活（或压栈）应用程序和请求上下文在分发请求之前，然后删除他们当请求被操作后。当应用程序上下文被压入栈，在线程中`current_app`和`g`变量变得可用；同样的，当请求上下文被压入栈，`request`和`session`变量也同样变得可用。如果这些变量中的任何一个不是由激活的应用程序或请求上下文访问，会产生错误。在后面的章节会详细讨论四个上下文变量，所以不要担心你不理解它们的用处。

下面的Python shell会话演示了应用程序上下文是如何工作的：

    >>> from hello import app
    >>> from flask import current_app
    >>> current_app.name
    Traceback (most recent call last):
    ...
    RuntimeError: working outside of the application context
    >>> app_ctx = app.app_context()
    >>> app_ctx.push()
    >>> current_app.name
    'hello'
    >>> app_ctx.pop()

在这个示例中，当没有应用程序上下文激活，但是却作为有效的上下文被压入栈中，`current_app.name`报错。注意在应用程序实例中一个应用程序上下文如何通过调用`app.app_context()`来获得。

#### **5.2、请求派发**

当一个应用程序从客户端收到一个请求，它需要找到调用哪个视图函数去服务它。对于这个任务，Flask在应用程序的URL _映射_ 中查找请求给的URL，该映射包含URLs和操作它们的视图函数的映射。Flask通过`app.route`装饰器或等价的非装饰器版本`app.add_url_rule()`建立这个映射。

看一下Flask应用程序中URL映射是怎样的，

#### **5.3、请求Hooks**

#### **5.4、响应**

### **6、Flask扩展**