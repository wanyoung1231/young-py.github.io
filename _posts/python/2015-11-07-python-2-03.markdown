---
layout: post
title:  "Python学习 —— 与Python无缝集成——基本特殊方法 3"
date:   2015-11-07 14:10:20
categories: python
author: young
---

### **__bool__()方法**

Python对假有个很好的定义。参考手册列出了大量的值,将测试相当于假。这包括诸如假,0,”,[](){ }。大多数其他对象将测试等同于事实。

通常,我们想要检查一个对象被“不空”用一个简单的语句,如下所示

if some_object:
       process( some_object )

下罩,这是布尔值()内置函数的工作。这个函数依赖于一个给定对象的布尔值()方法。

默认的布尔值()方法返回True。我们可以看到下面的代码

 >>> x = object()
   >>> bool(x)
   True

对于大多数类,这是非常有效的。大多数对象预计不会是假的。然而,对于集合,这是不合适的。一个空集合应该相当于假。一个非空的集合可以返回True。我们可能想要添加一个方法我们甲板对象。

如果我们包装列表,我们可能有一些,下面的代码片段所示

def __bool__( self ):
       return bool( self._cards )

这代表的布尔函数内部卡片收集。如果我们扩展列表,我们可能会有如下

def __bool__( self ):
       return super().__bool__( self )

这代表了超类的定义布尔值()函数。

在这两种情况下,我们speci卡莉委派逻辑测试。在包装的情况下,我们委托给集合。在延长的情况下,我们委托给超类。无论哪种方式,包装或扩展,一个空集合将是错误的。这将给我们一种甲板对象是否已经完全解决,是空的。

我们可以做的事情,下面的代码片段所示

d = Deck()
   while d:
       card= d.pop()
       # process the card

此循环将交易时所有的卡片不一个IndexError异常甲板已经筋疲力尽。

### **__bytes__()方法**

有相对较少的情况下将一个对象转换成字节。我们将在第2部分中详细看看这个,持久性和序列化。

在最常见的情况下,应用程序可以创建一个字符串表示,和Python的内置编码功能IO类将被用于将字符串转换成字节。这是完全在几乎所有的情况下。主要的例外是当我们德宁一种新的字符串。在这种情况下,我们需要不编码的字符串。

字节()函数做各种事情,这取决于参数

* 字节(整数):返回一个不可变的字节对象的给定的数字0 x00值。

* 字节(字符串):这将给定字符串字节编码。额外的参数编码和错误处理将不编码过程的细节。

* 字节():这将调用。字节()来创建一个字节对象。这里使用的编码或误差参数不会。

基本对象类不de ne字节()。这意味着我们的课程不提供一个默认字节()方法。

有一些特殊的情况下,我们可能会有一个对象,需要直接编码到字节被写入到勒之前。通常是简单的字符串和允许str类型产生字节。在处理字节时,重要的是要注意,没有简单的方法从勒解码字节或接口。内置的字节类只会解码字符串,不是我们独特的新对象。我们可能需要解析的字符串解码的字节。或者,我们可能需要显式地使用结构模块解析字节从解析和创建独特的对象值。

我们来看看编码和解码卡字节。作为只有52卡值,每张卡片可以包装成一个字节。然而,我们已经决定使用一个字符代表诉讼和一个字符来表示。此外,我们需要正确地重建卡的子类,所以我们必须编码几件事情

* 卡的子类(AceCard、NumberCard FaceCard

* subclass-de ned的参数初始化

请注意,我们的一些替代init()方法将一个数字等级转换成一个字符串,失去原来的数值。为了一个可逆的字节编码,我们需要重建这个原始数值等级值。

下面是一个实现的字节(),它返回一个utf - 8编码卡类的,等级,西装

def __bytes__( self ):
           class_code= self.__class__.__name__[0]
           rank_number_str = {'A': '1', 'J': '11', 'Q': '12', 'K': '13'}.
   get( self.rank, self.rank )
           string= "("+" ".join([class_code, rank_number_str, self.suit,]
   ) + ")"
           return bytes(string,encoding="utf8")

这是通过创建一个卡片对象的字符串表示,然后编码字符串到字节。这通常是最简单、最exible方法。

当我们有一堆字节,可以解码字符串,然后将字符串解析成一个新的卡片对象。下面是一个方法,可以用于创建一个卡片对象的字节

def card_from_bytes( buffer ):
       string = buffer.decode("utf8")
       assert string[0 ]=="(" and string[-1] == ")"
       code, rank_number, suit = string[1:-1].split()
       class_ = { 'A': AceCard, 'N': NumberCard, 'F': FaceCard }[code]
       return class_( int(rank_number), suit )

在前面的代码中,我们解码字节为一个字符串。然后我们该字符串解析为各个值。从这些值,我们可以定位和构建原始卡片对象的类。

我们可以建立一张卡片对象的字节表示如下

b= bytes(someCard)

我们可以重建卡对象的字节如下

someCard = card_from_bytes(b)

重要的是要注意,外部字节表示通常是具有挑战性的设计。我们创建一个表示一个对象的状态。Python已经有很多表示,适合我们班德定义。

通常是使用酸洗或json模块比发明的低字节表示一个对象。这是第九章的主题,序列化和储蓄JSON,YAML,泡菜,CSV,XML。

### **比较运算符方法**

Python有六个比较运算符。这些操作符有特殊的方法实现。根据文档,映射工作如下

* x<y calls x.__lt__(y)

* x<=y calls x.__le__(y)

* x==y calls x.__eq__(y)

* x!=y calls x.__ne__(y)

* x>y calls x.__gt__(y)

* x>=y calls x.__ge__(y)

我们会再次回到比较运算符在第七章看着数字时,创建的数字。

有一个额外的规则对运营商相关的实际实现。这些规则是基于认为左边的对象的类de nes所需的特殊方法。如果没有,Python可以尝试另一种操作通过改变订单。

这里有两个基本规则

首先,左边的操作数是检查经营者实现:< B意味着A lt(B)。

第二,右边的操作数是检查逆转算子实现:< B意味着B . gt(a)。

罕见的例外发生在正确的操作数是一个子类的左操作数;然后,正确的操作数是检查rst允许子类覆盖超类。

我们可以看到这是如何工作的德宁一个类只有一个运营商德奈德,然后使用其他操作。

以下是部分类,我们可以使用

class BlackJackCard_p:
       def __init__( self, rank, suit ):
           self.rank= rank
           self.suit= suit
       def __lt__( self, other ):
           print( "Compare {0} < {1}".format( self, other ) )
           return self.rank < other.rank
       def __str__( self ):
           return "{rank}{suit}".format( **self.__dict__ )

这是21点的比较规则,适合不重要。我们省略了比较的方法来了解Python会回退当操作员失踪。这个类将使我们能够执行<比较。有趣的是,Python还可以使用该执行>比较通过切换参数顺序。换句话说,x < y y > x。这是镜子重新检验规则;我们将在第七章再次见到它,创造数字。

我们看到当我们试图评估不同的比较操作。我们将创建两个卡类和比较它们以不同的方式,下面的代码片段所示

>>> two = BlackJackCard_p( 2, '♠' )
   >>> three = BlackJackCard_p( 3, '♠' )
   >>> two < three
   Compare 2♠ < 3♠
   True
   >>> two > three
   Compare 3♠ < 2♠
   False
   >>> two == three
   False
   >>> two <= three
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   TypeError: unorderable types: BlackJackCard_p() <= BlackJackCard_p()

从这,我们可以看到两个<三个映射到两个。lt(三)。

然而,对于2 > 3、没有de ned gt()方法;Python使用三种。lt(两个)作为一个后备计划

默认情况下,eq()方法是继承对象;它比较对象id;对象参与= =和!=测试如下

>>> two_c = BlackJackCard_p( 2, '♣' )
   >>> two == two_c
   False

我们可以看到,结果不是我们所期待。我们会经常需要覆盖默认的eq()的实现。

同样,没有运营商之间的逻辑连接。在数学上,我们可以从两个获得所有必要的比较。Python自动不这样做。相反,Python处理以下四个简单的检验对默认情况下

x<y≡y>x x≤y≡y≥x x=y≡y=x x≠y≡y≠x

至少,这意味着我们必须提供一个从每个四双。例如,我们可以提供eq(),(),lt()和()。

@functools。总订购装饰克服,并推导出其余的默认限制比较从情商()和其中的一个:lt(),(),gt()、通用电气()。我们将再次讨论这个在第7章,创造数字。

### **__del__()方法**

### **__new__()方法和不可变对象**

### **__new__()方法和metaclass**

### **总结**
