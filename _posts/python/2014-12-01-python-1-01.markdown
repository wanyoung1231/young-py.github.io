---
layout: post
title:  "Python学习 —— __init__()方法"
date:   2014-12-08 17:52:40
categories: python
author: young
---

`__init__()`方法深奥有两个原因。初始化是对象的生命周期最重要的一步；每个对象必须正确初始化后才能正常工作。第二个原因是`__init()__`参数值可以多种形式。

因为有很多种方式为`__init__()`提供参数值，有大量的用例用于对象创建。我们可以看看其中的几个。我们想尽可能的弄清楚，因此我们需要定义一个初始化来正确的表示问题区域。

在我们接触`__init__()`方法之前，无论如何，我们都需要粗略、简单地看看在Python中隐含的`object`类的层次结构。

在这一章，我们看看不同形式的简单对象的初始化（例如，打牌）。在这之后，我们可以看看更复杂的对象，就像手潜心于收集和玩家潜心于策略和状态。

### **隐含的超类——object**

每一个Python类都隐含了一个超类：**object**。它是一个非常简单的类定义，几乎不做任何事情。我们可以创建`object`的实例，但是我们不能用它做太多，因为许多特殊的方法容易抛出异常。

当我们定义一个自己的类，`object`则为超类。下面是一个类定义示例，它使用新的名称简单的继承了`object`：

    class X:
        pass

下面是和我们的类的一些交互：

    >>> X.__class__
    <class 'type'>
    >>> X.__class__.__base__
    <class 'object'>

我们可以看到类是`type`类的一个对象，且我们新类的基类为`object`。

就像在每个方法中看到的那样，我们也看看从`object`继承的默认行为。在某些情况下，超类特殊方法行为将是我们所想要的。在其他情况下，我们需要覆盖这个特殊方法。

### **基类对象的__init__()方法**

对象生命周期的基础是创建、初始化和销毁。我们将创建和销毁的更高级的特殊方法推迟到后面的章节，目前只关注初始化。

所有类的超类`object`，有一个默认的`__init__()`实现。我们不需要去实现`__init__()`。如果不实现它，则在对象创建后就不会创建实例变量。在某些情况下，这个默认行为是可以接受的。

我们通常增加给对象添加属性，该对象为基类`object`的子类。思考以下类，需要两个实例变量但不初始化它们：

{% highlight python %}

class Rectangle:
    def area( self ):
        return self.length * self.width

{% endhighlight %}

`Rectangle`类有一个使用两个属性来返回一个值的方法。这些属性没有初始化。这是合法的Python代码。它可以有效的避免专门设置属性，虽然有点奇怪，但是有效。

下面是于Rectangle类的交互：

    >>> r= Rectangle()
    >>> r.length, r.width = 13, 8
    >>> r.area()
    104

显然这是合法的，但也是容易混淆的根源，所以需要避免。

无论如何，这个设计给予了很大的灵活性，这样有时候我们不用在`__init__()`方法中设置所有属性。至此我们走的很顺利。一个可选属性其实就是一个没有正式声明为一个合适的子类。我们创建多态的方式可能会引起混乱和复杂的`if`语句的不当使用。虽然未初始化的属性可能是有用的，但很有可能是糟糕设计的前兆。

《Python之禅》中的建议：

> "显式比隐式更好。"

`__init__()`方法应该使实例变量显式。

**可怜的多态性**

灵活和愚蠢就在一念之间。

当我们觉得需要像下面这样写的时候，我们正从灵活的边缘走向愚蠢：

    if 'x' in self.__dict__:

或者：
    
    try:
        self.x
    except AttributeError:

是时候重新考虑API并添加一个常见的方法或属性。重构比添加`if`语句更明智。

### **在超类中实现__init__()**

我们通过实现`__init__()`方法来初始化对象。当一个对象被创建，Python首先创建一个空对象，然后为那个新对象调用`__init__()`方法。这个方法函数通常用来创建对象的实例变量和执行任何其他一次性处理。

下面是`Card`类示例定义的层次结构。我们将定义`Card`超类和三个子类，这三个子类是`Card`的变种。两个实例变量直接由参数值设置，两个变量通过初始化方法计算：

{% highlight python %}

class Card:
    def  __init__( self, rank, suit ):
        self.suit= suit
        self.rank= rank
        self.hard, self.soft = self._points()

class NumberCard( Card ):
    def _points( self ):
        return int(self.rank), int(self.rank)

class AceCard( Card ):
    def _points( self ):
        return 1, 11

class FaceCard( Card ):
    def _points( self ):
        return 10, 10

{% endhighlight %}

在这个示例中，我们提取出`__init__()`方法到超类，这样在`Card`超类中的通用初始化可以适用于三个子类`NumberCard`、`AceCard`和`FaceCard`。

这是一种常见的多态设计。每一个子类都提供一个唯一的`_points()`方法。所有子类都有相同的签名：有相同的方法和属性。这三个子类的对象在一个应用程序中可以交替使用。

如果我们为花色简单的使用字符，我们可以创建`Card`实例，如下所示：

    cards = [ AceCard('A', '♠'), NumberCard('2','♠'), NumberCard('3','♠'),]

我们为一些牌枚举出类、牌值和花色到列表中。从长远来说，我们需要更智能的工厂函数来创建`Card`实例；用这个方法枚举52张牌无聊且容易出错。在我们接触工厂函数之前，我们看看一些其他问题。

### **使用__init__()创建显示常量**

可以给我们的牌定义花色类。在二十一点中，花色无关紧要，简单的字符串就可以。

我们使用花色构造函数作为创建常量对象的示例。在许多情况下，我们应用中小部分领域的对象可以通过常量集合来定义。小部分的静态对象可能是实现**Strategy**或**State**设计模式的一部分。



